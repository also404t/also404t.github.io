<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nginx地址重写及location配置</title>
      <link href="/2021/08/14/nginx/nginx%E5%9C%B0%E5%9D%80%E9%87%8D%E5%86%99%E5%8F%8Alocation%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/08/14/nginx/nginx%E5%9C%B0%E5%9D%80%E9%87%8D%E5%86%99%E5%8F%8Alocation%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1、nginx-地址重写-rewrite"><a href="#1、nginx-地址重写-rewrite" class="headerlink" title="1、nginx 地址重写 rewrite"></a>1、nginx 地址重写 rewrite</h3><h5 id="1、什么是Rewrite"><a href="#1、什么是Rewrite" class="headerlink" title="1、什么是Rewrite"></a>1、什么是Rewrite</h5><pre><code>Rewrite对称URL Rewrite，即URL重写，就是把传入Web的请求重定向到其他URL的过程。</code></pre><ul><li>URL Rewrite最常见的应用是URL伪静态化，是将动态页面显示为静态页面方式的一种技术。比如<br><a href="http://www.123.com/news/index.php?id=123">http://www.123.com/news/index.php?id=123</a> 使用URLRewrite 转换后可以显示为 <a href="http://www.123/">http://www.123</a> .com/news/123.html对于追求完美主义的网站设计师，就算是网页的地址也希望看起来尽量简洁明快。<br>理论上，搜索引擎更喜欢静态页面形式的网页，搜索引擎对静态页面的评分一般要高于动态页面。所以，UrlRewrite可以让我们网站的网页更容易被搜索引擎所收录。</li><li>从安全角度上讲，如果在URL中暴露太多的参数，无疑会造成一定量的信息泄漏，可能会被一些黑客<br>利用，对你的系统造成一定的破坏，所以静态化的URL地址可以给我们带来更高的安全性。</li><li>实现网站地址跳转，例如用户访问360buy.com，将其跳转到jd.com。例如当用户访问tianyun.com的<br>80端口时，将其跳转到443端口。</li><li>重写之后的url更为简洁美观</li></ul><h5 id="2、Rewrite-相关指令"><a href="#2、Rewrite-相关指令" class="headerlink" title="2、Rewrite 相关指令"></a>2、Rewrite 相关指令</h5><ul><li><strong>Nginx Rewrite 相关指令有 if 、rewrite、set、return</strong></li></ul><h6 id="2-1、if-语句"><a href="#2-1、if-语句" class="headerlink" title="2.1、if 语句"></a>2.1、if 语句</h6><ul><li><p>应用环境</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server，location<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if (condition) &#123; … &#125;if 可以支持如下条件判断匹配符号~ 正则匹配 (区分大小写)~*     正则匹配 (不区分大小写)!~                  正则不匹配 (区分大小写)!~*            正则不匹配  (不区分大小写)-f 和!-f     用来判断是否存在文件-d 和!-d     用来判断是否存在目录-e 和!-e     用来判断是否存在文件或目录-x 和!-x     用来判断文件是否可执行在匹配过程中可以引用一些Nginx的全局变量$args请求中的参数;$document_root    针对当前请求的根路径设置值;$host请求信息中的&quot;Host&quot;，如果请求中没有Host行，则等于设置的服务器名;$limit_rate对连接速率的限制;$request_method请求的方法，比如&quot;GET&quot;、&quot;POST&quot;等;$remote_addr客户端地址;$remote_port客户端端口号;$remote_user客户端用户名，认证用;$request_filename   当前请求的文件路径名（带网站的主目录&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;images&#x2F;a.jpg）$request_uri当前请求的文件路径名（不带网站的主目录&#x2F;images&#x2F;a.jpg）$query_string与$args相同;$scheme用的协议，比如http或者是https$server_protocol请求的协议版本，&quot;HTTP&#x2F;1.0&quot;或&quot;HTTP&#x2F;1.1&quot;;$server_addr 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费);$server_name请求到达的服务器名;$document_uri 与$uri一样，URI地址;$server_port 请求到达的服务器端口号;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-2、Rewrite-flag"><a href="#2-2、Rewrite-flag" class="headerlink" title="2.2、Rewrite flag"></a>2.2、Rewrite flag</h6><p><strong>rewrite</strong>  指令根据表达式来重定向URI，或者修改字符串。可以应用于<strong>server,location, if</strong>环境下每行rewrite指令最后跟一个flag标记，支持的flag标记有：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">last     相当于Apache里的[L]标记，表示完成rewrite。默认为last。break 本条规则匹配完成后，终止匹配，不再匹配后面的规则redirect 返回302临时重定向，浏览器地址会显示跳转后的URL地址permanent     返回301永久重定向，浏览器地址会显示跳转后URL地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>redirect 和 permanent区别则是返回的不同方式的重定向，对于客户端来说一般状态下是没有区别的。而对于搜索引擎，相对来说301的重定向更加友好，如果我们把一个地址采用301跳转方式跳转的话，搜索引擎会把老地址的相关信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。使用302重定向时，搜索引擎(特别是google)有时会查看跳转前后哪个网址更直观，然后决定显示哪个，如果它觉的跳转前的URL更好的话，也许地址栏不会更改，那么很有可能出现URL劫持的现像。在做URI重写时，有时会发现URI中含有相关参数，如果需要将这些参数保存下来，并且在重写过程中重新引用，可以利用重定向 () 和 $N 的方式来解决。</p></li></ul><p>2.3、Rewrite匹配参考示例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">本地解析host文件# http:&#x2F;&#x2F;www.testpm.com&#x2F;a&#x2F;1.html &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.testpm.com&#x2F;b&#x2F;2.html    location &#x2F;a &#123;           root    &#x2F;html;              index   1.html index.htm;        rewrite .* &#x2F;b&#x2F;2.html permanent;        &#125;    location &#x2F;b &#123;        root    &#x2F;html;        index   2.html index.htm;        &#125;例2：# http:&#x2F;&#x2F;www.testpm.com&#x2F;2019&#x2F;a&#x2F;1.html &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.testpm.com&#x2F;2018&#x2F;a&#x2F;1.html     location &#x2F;2019&#x2F;a &#123;        root    &#x2F;var&#x2F;www&#x2F;html;        index   1.html index.hml;        rewrite ^&#x2F;2019&#x2F;(.*)$ &#x2F;2018&#x2F;$1 permanent;        &#125;     location &#x2F;2018&#x2F;a &#123;        root    &#x2F;var&#x2F;www&#x2F;html;        index   1.html index.htl;        &#125;例3：# http:&#x2F;&#x2F;www.qf.com&#x2F;a&#x2F;1.html &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;jd.comlocation &#x2F;a &#123;        root    &#x2F;html;        if ($host ~* www.qf.com ) &#123;        rewrite .* http:&#x2F;&#x2F;jd.com permanent;        &#125;        &#125;例4: 在访问目录后添加&#x2F;  (如果目录后已有&#x2F;，则不加&#x2F;)# http:&#x2F;&#x2F;www.tianyun.com&#x2F;a&#x2F;b&#x2F;c# $1: &#x2F;a&#x2F;b# $2: c# http:&#x2F;&#x2F;$host$1$2$3&#x2F;location &#x2F;a&#x2F;b&#x2F;c &#123;        root    &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index   index.html index.hml;        if (-d $request_filename) &#123;        rewrite ^(.*)([^&#x2F;])$ http:&#x2F;&#x2F;$host$1$2&#x2F; permanent;        &#125;        &#125;例5：# http:&#x2F;&#x2F;www.tianyun.com&#x2F;login&#x2F;tianyun.html &#x3D;&#x3D;&gt;  http:&#x2F;&#x2F;www.tianyun.com&#x2F;reg&#x2F;login.html?user&#x3D;tianyunlocation &#x2F;login &#123;        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        rewrite ^&#x2F;login&#x2F;(.*)\.html$ http:&#x2F;&#x2F;$host&#x2F;reg&#x2F;login.html?user&#x3D;$1;        &#125;    location &#x2F;reg &#123;        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index login.html;        &#125;例6：#http:&#x2F;&#x2F;www.tianyun.com&#x2F;qf&#x2F;11-22-33&#x2F;1.html  &#x3D;&#x3D;&gt;  http:&#x2F;&#x2F;www.tianyun.com&#x2F;qf&#x2F;11&#x2F;22&#x2F;33&#x2F;1.htmllocation &#x2F;qf &#123;            rewrite ^&#x2F;qf&#x2F;([0-9]+)-([0-9]+)-([0-9]+)(.*)$ &#x2F;qf&#x2F;$1&#x2F;$2&#x2F;$3$4 permanent;        &#125;        location &#x2F;qf&#x2F;11&#x2F;22&#x2F;33 &#123;                root &#x2F;html;                index   1.html;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-4、set-指令"><a href="#2-4、set-指令" class="headerlink" title="2.4、set 指令"></a>2.4、set 指令</h6><p>set 指令是用于定义一个变量，并且赋值</p><p>应用环境:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server,location,if<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应用示例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">例8：#http:&#x2F;&#x2F;alice.testpm.com &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.testpm.com&#x2F;alice#http:&#x2F;&#x2F;jack.testpm.com &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.testpm.com&#x2F;jack[root@nginx-server conf.d]# cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;[root@nginx-server html]# mkdir jack alice[root@nginx-server html]# echo &quot;jack..&quot; &gt;&gt; jack&#x2F;index.html[root@nginx-server html]# echo &quot;alice..&quot; &gt;&gt; alice&#x2F;index.htmla. DNS实现泛解析*   IN      A    网站IP或者本地解析域名host文件10.0.105.202 www.testpm.com10.0.105.202 alice.testpm.com10.0.105.202 jack.testpm.com编辑配置文件:server &#123;    listen       80;    server_name  www.testpm.com;    location &#x2F; &#123;         root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;         index  index.html index.htm;         if ( $host ~* ^www.testpm.com$) &#123;                break;                &#125;         if ( $host ~* &quot;^(.*)\.testpm\.com$&quot; ) &#123;                set $user $1;                rewrite .* http:&#x2F;&#x2F;www.testpm.com&#x2F;$user permanent;                &#125;        &#125;    location &#x2F;jack &#123;         root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;         index  index.html index.hml;        &#125;    location &#x2F;alice &#123;         root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;         index index.html index.hml;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-5、return-指令"><a href="#2-5、return-指令" class="headerlink" title="2.5、return 指令"></a>2.5、return 指令</h6><p>return 指令用于返回状态码给客户端</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server,location,if<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应用示例:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">例9：如果访问的.sh结尾的文件则返回403操作拒绝错误server &#123;    listen       80;    server_name  www.testpm.cn;    #access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;http_access.log  main;    location &#x2F; &#123;        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index  index.html index.htm;        &#125;    location ~* \.sh$ &#123;        return 403;        &#125;&#125;例10：80 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 443 ：80转443端口server &#123;    listen       80;    server_name  www.testpm.cn;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;http_access.log  main;    return 301 https:&#x2F;&#x2F;www.testpm.cn$request_uri;&#125;server &#123;    listen 443 ssl;    server_name www.testpm.cn;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;https_access.log  main;    #ssl on;   以下步骤为域名www.testpm.cn绑定ssl证书    ssl_certificate   &#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;2447549_www.testpm.cn.pem;    ssl_certificate_key  &#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;2447549_www.testpm.cn.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;    ssl_prefer_server_ciphers on;    location &#x2F; &#123;        root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index index.html index.htm;    &#125;&#125;[root@nginx-server ~]# curl -I http:&#x2F;&#x2F;www.testpm.cnHTTP&#x2F;1.1 301 Moved PermanentlyServer: nginx&#x2F;1.16.0Date: Wed, 03 Jul 2019 13:52:30 GMTContent-Type: text&#x2F;htmlContent-Length: 169Connection: keep-aliveLocation: https:&#x2F;&#x2F;www.testpm.cn&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、last,break详解</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost test]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;last_break.conf server &#123;    listen       80;    server_name  localhost;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;last.access.log  main;    location &#x2F; &#123;        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index  index.html index.htm;    &#125;    location &#x2F;break&#x2F; &#123;        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        rewrite .* &#x2F;test&#x2F;break.html break;    &#125;    location &#x2F;last&#x2F; &#123;        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        rewrite .* &#x2F;test&#x2F;last.html last;    &#125;    location &#x2F;test&#x2F; &#123;        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        rewrite .* &#x2F;test&#x2F;test.html break;    &#125;&#125;[root@localhost conf.d]# cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;[root@localhost html]# mkdir test[root@localhost html]# echo &quot;last&quot; &gt; test&#x2F;last.html[root@localhost html]# echo &quot;break&quot; &gt; test&#x2F;break.html[root@localhost html]# echo &quot;test&quot; &gt; test&#x2F;test.htmlhttp:&#x2F;&#x2F;10.0.105.196&#x2F;break&#x2F;break.htmlhttp:&#x2F;&#x2F;10.0.105.196&#x2F;last&#x2F;last.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><ul><li><p>last 标记在本条 rewrite 规则执行完后，会对其所在的 server { … } 标签重新发起请求; </p></li><li><p>break 标记则在本条规则匹配完成后，停止匹配，不再做后续的匹配；</p></li><li><p>使用 proxy_pass 指令时,则必须使用break。</p><p><strong>4、Nginx 的 https  ( rewrite )</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">server  &#123;     listen       80;    server_name  *.vip9999.top vip9999.top;      if ($host ~* &quot;^www.vip9999.top$|^vip9999.top$&quot; ) &#123;            return 301 https:&#x2F;&#x2F;www.vip9999.top$request_uri;    &#125;      if ($host ~* &quot;^(.*).vip9999.top$&quot; ) &#123;            set $user $1;            return 301 https:&#x2F;&#x2F;www.vip9999.top&#x2F;$user;    &#125;  &#125;  # Settings for a TLS enabled server.server &#123;    listen       443 ssl;    server_name  www.vip9999.top;      location &#x2F; &#123;            root      &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;            index     index.php index.html;    &#125;      #pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    location ~ \.php$ &#123;        root           &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        fastcgi_pass   127.0.0.1:9000;        fastcgi_index  index.php;        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        include        fastcgi_params;    &#125;    ssl on;    ssl_certificate cert&#x2F;214025315060640.pem;    ssl_certificate_key cert&#x2F;214025315060640.key;    ssl_session_cache shared:SSL:1m;    ssl_session_timeout  10m;    ssl_ciphers HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers on;    &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="nginx-try-files-用法s"><a href="#nginx-try-files-用法s" class="headerlink" title="nginx try_files 用法s"></a>nginx try_files 用法s</h4><table><thead><tr><th align="left">Syntax:</th><th>try_files   file … uri;   try_files    file … =code;</th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td>server,    location</td></tr></tbody></table><p>按指定顺序检查文件是否存在，并使用第一个找到的文件进行请求处理；处理是在当前上下文中执行的。文件的路径是<code>file</code>根据<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#root">root</a>和<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#alias">alias</a>指令从参数 构造的 。可以通过在名称末尾指定斜杠来检查目录是否存在，例如 <code>$uri/</code>。如果没有找到任何文件，<code>uri</code>则进行到最后一个参数中指定的内部重定向 。例如：</p><blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location &#x2F;images&#x2F; &#123;     try_files $uri &#x2F;images&#x2F;default.gif; &#125; location &#x3D; &#x2F;images&#x2F;default.gif &#123;    expires 30s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>最后一个参数也可以指向一个命名位置，如下面的示例所示。从 0.7.51 版本开始，最后一个参数也可以是一个 <code>code</code>：</p><blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location &#x2F; &#123;     try_files $uri $uri&#x2F;index.html  $uri.html &#x3D; 404; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>更多try_files用法参考：<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#try_files">https://nginx.org/en/docs/http/ngx_http_core_module.html#try_files</a></p></li></ul><h3 id="2、nginx的localtion指令详解"><a href="#2、nginx的localtion指令详解" class="headerlink" title="2、nginx的localtion指令详解"></a>2、nginx的localtion指令详解</h3><p>Nginx 的 HTTP 配置主要包括三个区块，结构如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">http &#123; # 这个是协议级别　　include mime.types;　　default_type application&#x2F;octet-stream;　　keepalive_timeout 65;　　gzip on;　　　　server &#123; # 这个是服务器级别　　　　　　listen 80;　　　　　　server_name localhost;　　　　　　　　location &#x2F; &#123;  # 这个是请求级别　　　　　　　　　　root html;　　　　　　　　　　index index.html index.htm;　　　　　　　　&#125;　　　　　　&#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1、location-区段"><a href="#1、location-区段" class="headerlink" title="1、location 区段"></a>1、location 区段</h5><ul><li><p>location 是在 server 块中配置，根据不同的 URI 使用不同的配置，来处理不同的请求。</p></li><li><p>location 是有顺序的，会被第一个匹配的location 处理。</p></li><li><p>基本语法如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location [&#x3D;|~|~*|^~|@] pattern&#123;……&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="2、location-前缀含义"><a href="#2、location-前缀含义" class="headerlink" title="2、location 前缀含义"></a>2、<strong>location 前缀含义</strong></h5>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x3D;    表示精确匹配，优先级也是最高的 ^~   表示uri以某个常规字符串开头,理解为匹配url路径即可 ~    表示区分大小写的正则匹配  ~*   表示不区分大小写的正则匹配!~   表示区分大小写不匹配的正则!~*  表示不区分大小写不匹配的正则&#x2F;    通用匹配，任何请求都会匹配到@    内部服务跳转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3、location-配置示例"><a href="#3、location-配置示例" class="headerlink" title="3、location 配置示例"></a>3、location 配置示例</h5><p>  本地解析域名host</p><p>  1、没有修饰符 表示：必须以指定模式开始</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server &#123;    listen       80;    server_name  qf.com;    location  &#x2F;abc &#123;        root    &#x2F;home&#x2F;www&#x2F;nginx;        index   2.html;        &#125;那么，如下是对的：http:&#x2F;&#x2F;qf.com&#x2F;abchttp:&#x2F;&#x2F;qf.com&#x2F;abc?p1http:&#x2F;&#x2F;qf.com&#x2F;abc&#x2F;http:&#x2F;&#x2F;qf.com&#x2F;abcde <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2、=表示：必须与指定的模式精确匹配</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server &#123;    listen       80;    server_name  www.testpm.cn;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;http_access.log  main;    location &#x2F; &#123;        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index index.html index.htm;    &#125;    location &#x3D; &#x2F;abc &#123;        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index index.html index.htm;    &#125;&#125;那么，如下是对的：http:&#x2F;&#x2F;qf.com&#x2F;abchttp:&#x2F;&#x2F;qf.com&#x2F;abc?p1http:&#x2F;&#x2F;qf.com&#x2F;abc&#x2F;如下是错的http:&#x2F;&#x2F;qf.com&#x2F;abcde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  3、~ 表示：指定的正则表达式要区分大小写</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server &#123;server_name qf.com;　　location ~ ^&#x2F;abc$ &#123;　　　　……　　&#125;&#125;那么，如下是对的：http:&#x2F;&#x2F;qf.com&#x2F;abchttp:&#x2F;&#x2F;qf.com&#x2F;abc?p1&#x3D;11&amp;p2&#x3D;22如下是错的http:&#x2F;&#x2F;qf.com&#x2F;ABChttp:&#x2F;&#x2F;qf.com&#x2F;abc&#x2F;http:&#x2F;&#x2F;qf.com&#x2F;abcde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  4、~* 表示：指定的正则表达式不区分大小写</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server &#123;server_name qf.com;location ~* ^&#x2F;abc$ &#123;　　　　……　　&#125;&#125;那么，如下是对的：http:&#x2F;&#x2F;qf.com&#x2F;abchttp:&#x2F;&#x2F;qf.com&#x2F;ABChttp:&#x2F;&#x2F;qf.com&#x2F;abc?p1&#x3D;11&amp;p2&#x3D;22如下是错的：http:&#x2F;&#x2F;qf.com&#x2F;abc&#x2F;http:&#x2F;&#x2F;qf.com&#x2F;abcde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  5、^~ ：类似于无修饰符的行为，也是以指定模式开始，不同的是，如果模式匹配，那么就停止搜索其他模式了。<br>  6、@ ：定义命名 location 区段，这些区段客户段不能访问，只可以由内部产生的请求来访问，如try_files或error_page等</p><p>  <strong>查找顺序和优先级</strong></p><p>  <strong>1：带有 = 的精确匹配优先</strong></p><p>  <strong>2：没有修饰符的精确匹配</strong></p><p>  <strong>3：正则表达式按照他们在配置文件中定义的顺序</strong></p><p>  <strong>4：带有 ^~ 修饰符的，开头匹配</strong></p><p>  <em><em>5：带有 ~  或 ~</em>  修饰符的，如果正则表达式与URI匹配</em>*</p><p>  <strong>6：没有修饰符的，如果指定字符串与URI开头匹配</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x3D; 大于 ^~  大于 ~|~*|!~|!~* 大于 &#x2F;多个location配置的情况下匹配顺序为：首先匹配 &#x3D;，其次匹配^~, 其次是按正则匹配，最后是交给 &#x2F; 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;(1) &#x3D;:表示完全匹配;(2) ^~:匹配URI的前缀，并且后面的正则表达式不再匹配，如果一个URI同时满足两个规则的话，匹配最长的规则;(3) ~:匹配正则表达式，大小写敏感；(4) ~*:匹配正则表达式，大小写不敏感；优先级：（1）&gt; (2) &gt; (3) &#x3D; (4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location 区段匹配示例location &#x3D; &#x2F; &#123;　　# 只匹配 &#x2F; 的查询.　　[ configuration A ]&#125;location &#x2F; &#123;　　# 匹配任何以 &#x2F; 开始的查询，但是正则表达式与一些较长的字符串将被首先匹配。　　[ configuration B ]&#125;location ^~ &#x2F;images&#x2F; &#123;　　# 匹配任何以 &#x2F;images&#x2F; 开始的查询并且停止搜索，不检查正则表达式。　　[ configuration C ]&#125;location ~* \.(gif|jpg|jpeg)$ &#123;　　# 匹配任何以gif, jpg, or jpeg结尾的文件，但是所有 &#x2F;images&#x2F; 目录的请求将在Configuration C中处理。　　[ configuration D ]&#125; 各请求的处理如下例：&#x2F; → configuration A&#x2F;documents&#x2F;document.html → configuration B&#x2F;images&#x2F;1.gif → configuration C&#x2F;documents&#x2F;1.jpg → configuration D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、root 、alias 指令区别</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location &#x2F;img&#x2F; &#123;    alias &#x2F;var&#x2F;www&#x2F;image&#x2F;;&#125;#若按照上述配置的话，则访问&#x2F;img&#x2F;目录里面的文件时，ningx会自动去&#x2F;var&#x2F;www&#x2F;image&#x2F;目录找文件location &#x2F;img&#x2F; &#123;    root &#x2F;var&#x2F;www&#x2F;image;&#125;#若按照这种配置的话，则访问&#x2F;img&#x2F;目录下的文件时，nginx会去&#x2F;var&#x2F;www&#x2F;image&#x2F;img&#x2F;目录下找文件。]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>alias 是一个目录别名的定义，</li><li>root 则是最上层目录的定义。</li><li>还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的,而root则可有可无</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> rewrite </tag>
            
            <tag> location </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx反向代理与负载均衡</title>
      <link href="/2021/08/14/nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2021/08/14/nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1、nginx-Proxy-代理"><a href="#1、nginx-Proxy-代理" class="headerlink" title="1、nginx Proxy 代理"></a>1、nginx Proxy 代理</h3><p><strong>1、nginx Proxy 配置</strong></p><p>1、代理模块</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ngx_http_proxy_module<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、代理配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">代理Syntax: proxy_pass URL;   #代理的后端服务器URLDefault: —Context: location, if in location, limit_except缓冲区Syntax:     proxy_buffering on | off;Default:    proxy_buffering on;   #缓冲开关Context: http, server, locationproxy_buffering开启的情况下，nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端（边收边传，不是全部接收完再传给客户端)。Nginx 全局配置中的 tcp_nopush 的作用就是 数据包会累计到一定大小之后才会发送 。而 tcp_nodelay 是尽快发送数据，所以若你启用了 buffer，建议关闭 tcp_nodelay。Syntax:   proxy_buffer_size size;Default: proxy_buffer_size 4k|8k;   #缓冲区大小Context: http, server, locationSyntax: proxy_buffers number size;Default: proxy_buffers 8 4k|8k;   #缓冲区数量Context: http, server, locationSyntax:    proxy_busy_buffers_size size;Default: proxy_busy_buffers_size 8k|16k;#忙碌的缓冲区大小控制同时传递给客户端的buffer数量Context: http, server, location头信息Syntax: proxy_set_header field value;Default: proxy_set_header Host $proxy_host;#设置真实客户端地址            proxy_set_header Connection close;Context: http, server, location超时Syntax: proxy_connect_timeout time;Default: proxy_connect_timeout 60s;#链接超时Context: http, server, locationSyntax: proxy_read_timeout time;Default: proxy_read_timeout 60s;Context: http, server, locationSyntax: proxy_send_timeout time; #nginx进程向fastcgi进程发送request的整个过程的超时时间Default: proxy_send_timeout 60s;Context: http, server, location#buffer 工作原理1. 所有的proxy buffer参数是作用到每一个请求的。每一个请求会安按照参数的配置获得自己的buffer。proxy buffer不是global而是 request的。2. proxy_buffering 是为了开启response buffering of the proxied server，开启后proxy_buffers和proxy_busy_buffers_size参数才会起作用。3. 无论proxy_buffering是否开启，proxy_buffer_size（main buffer）都是工作的，proxy_buffer_size所设置的buffer_size的作用是用来存储upstream端response的header。4. 在proxy_buffering 开启的情况下，Nginx将会尽可能的读取所有的upstream端传输的数据到buffer，直到proxy_buffers设置的所有buffer们 被写满或者数据被读取完(EOF)。此时nginx开始向客户端传输数据，会同时传输这一整串buffer们。同时如果response的内容很大的话，Nginx会接收并把他们写入到temp_file里去。大小由proxy_max_temp_file_size控制。如果busy的buffer 传输完了会从temp_file里面接着读数据，直到传输完毕。5. 一旦proxy_buffers设置的buffer被写入，直到buffer里面的数据被完整的传输完（传输到客户端），这个buffer将会一直处 在busy状态，我们不能对这个buffer进行任何别的操作。所有处在busy状态的buffer size加起来不能超过proxy_busy_buffers_size，所以proxy_busy_buffers_size是用来控制同时传输到客户端的buffer数量的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、启用 nginx proxy 代理</strong></p><p>环境两台nginx真实服务器</p><p>a、nginx-1 启动网站(内容)（作为网站服务器）</p><p>b、nginx-2 启动代理程序</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx-2的ip:10.0.105.202配置nginx的yum源直接yum安装启动编辑nginx的配置文件:[root@nginx-server ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.confserver &#123;    server &#123;    listen       80;    server_name  localhost;    location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;10.0.105.199:80;    proxy_redirect default;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    #proxy_set_header REMOTE-HOST $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_connect_timeout 30;    proxy_send_timeout 60;    proxy_read_timeout 60;    proxy_buffering on;    proxy_buffer_size 32k;    proxy_buffers 4 128k;    proxy_busy_buffers_size 256k;    proxy_max_temp_file_size 256k;    &#125;&#125;重新加载nginx配置文件[root@nginx-server ~]# nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>c、nginx proxy 具体配置详解</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">proxy_pass ：真实服务器的地址，可以是ip也可以是域名和url地址proxy_redirect ：如果真实服务器使用的是的真实IP:非默认端口。则改成IP：默认端口。proxy_set_header：重新定义或者添加发往后端服务器的请求头proxy_set_header X-Real-IP ：启用客户端真实地址（否则日志中显示的是代理在访问网站）proxy_set_header X-Forwarded-For：记录代理地址proxy_connect_timeout：:后端服务器连接的超时时间发起三次握手等候响应超时时间proxy_send_timeout：后端服务器数据回传时间就是在规定时间之内后端服务器必须传完所有的数据proxy_read_timeout ：nginx接收upstream（上游&#x2F;真实） server数据超时, 默认60s, 如果连续的60s内没有收到1个字节, 连接关闭。像长连接proxy_buffering on;开启缓存proxy_buffer_size：proxy_buffer_size只是响应头的缓冲区proxy_buffers 4 128k; 内容缓冲区域大小proxy_busy_buffers_size 256k; 从proxy_buffers划出一部分缓冲区来专门向客户端传送数据的地方proxy_max_temp_file_size 256k;超大的响应头存储成文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">proxy_set_header X-Real-IP 未配置Nginxbackend 的日志：记录只有192.168.107.112配置Nginxbackend 的日志,记录的有192.168.107.16 192.168.107.107 192.168.107.112proxy_buffers 的缓冲区大小一般会设置的比较大，以应付大网页。 proxy_buffers当中单个缓冲区的大小是由系统的内存页面大小决定的，Linux系统中一般为4k。 proxy_buffers由缓冲区数量和缓冲区大小组成的。总的大小为number*size。若某些请求的响应过大,则超过_buffers的部分将被缓冲到硬盘(缓冲目录由_temp_path指令指定), 当然这将会使读取响应的速度减慢, 影响用户体验. 可以使用proxy_max_temp_file_size指令关闭磁盘缓冲.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多详细代理设置参考官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header</a></p><p>观察nginx-1服务器的日志 (记得打开下面的日志路径,默认为/var/log)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">10.0.105.202 - - [27&#x2F;Jun&#x2F;2019:15:54:17 +0800] &quot;GET &#x2F; HTTP&#x2F;1.0&quot; 304 0 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.100 Safari&#x2F;537.36&quot; &quot;10.0.105.207&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>10.0.105.202  代理服务器地址</p><p>10.0.105.207 客户机地址。</p><p>访问成功。 记录了客户机的IP和代理服务器的IP</p><h3 id="2、Nginx负载均衡"><a href="#2、Nginx负载均衡" class="headerlink" title="2、Nginx负载均衡"></a>2、Nginx负载均衡</h3><p><a href="https://zhuanlan.zhihu.com/p/64777456">https://zhuanlan.zhihu.com/p/64777456</a>  知乎对7层负载的介绍</p><h6 id="1、负载均衡的作用"><a href="#1、负载均衡的作用" class="headerlink" title="1、负载均衡的作用"></a>1、负载均衡的作用</h6><p>如果你的nginx服务器给2台web服务器做代理，负载均衡算法采用轮询，那么当你的一台机器web程序关闭造成web不能访问，那么nginx服务器分发请求还是会给这台不能访问的web服务器，如果这里的响应连接时间过长，就会导致客户端的页面一直在等待响应，对用户来说体验就打打折扣，这里我们怎么避免这样的情况发生呢。</p><p>如果负载均衡中其中web2发生这样的情况，nginx首先会去web1请求，但是nginx在配置不当的情况下会继续分发请求道web2，然后等待web2响应，直到我们的响应时间超时，才会把请求重新分发给web1，这里的响应时间如果过长，用户等待的时间就会越长。</p><p>下面的配置是解决方案之一。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">proxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否中断对被代理服务器的请求。默认为off。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用upstream指令配置一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一组服务器处理.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">proxy_next_upstream timeout;  #反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误。</p><p>timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时。</p><p>invalid_header:被代理服务器返回的响应头异常。</p><p>off:无法将请求分发给被代理的服务器。</p><p>http_400，….:被代理服务器返回的状态码为400，500，502，等</p><p>2、upstream配置</p><p>首先给大家说下 upstream 这个配置的，这个配置是写一组被代理的服务器地址，然后配置负载均衡的算法。这里的被代理服务器地址有2中写法。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream testapp &#123;       server 10.0.105.199:8081;      server 10.0.105.202:8081;    &#125; server &#123;        ....        location &#x2F; &#123;                    proxy_pass  http:&#x2F;&#x2F;testapp;  #请求转向 testapp 定义的服务器列表                 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream mysvr &#123;       server  http:&#x2F;&#x2F;10.0.105.199:8081;      server  http:&#x2F;&#x2F;10.0.105.202:8081;    &#125; server &#123;        ....        location  &#x2F; &#123;                    proxy_pass  http:&#x2F;&#x2F;mysvr;  #请求转向mysvr 定义的服务器列表                 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="1、负载均衡算法"><a href="#1、负载均衡算法" class="headerlink" title="1、负载均衡算法"></a>1、负载均衡算法</h6><p>upstream 支持4种负载均衡调度算法:</p><p>A、<code>轮询(默认)</code>:每个请求按时间顺序逐一分配到不同的后端服务器;</p><p>B、<code>ip_hash</code>:每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</p><p>C、<code>url_hash</code>:按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器。后台服务器为缓存的时候提高效率。</p><p>D、<code>fair</code>:这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。<code>Nginx</code>本身是不支持 <code>fair</code>的，如果需要使用这种调度算法，必须下载Nginx的 <code>upstream_fair</code>模块。</p><p><strong>2、配置实例</strong></p><p>1、热备：如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB…..</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;       server 172.17.14.3:8080 backup;  #热备         &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、轮询：nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB….</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;      server 172.17.14.3:8080;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3、加权轮询：跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB….</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080 weight&#x3D;1;      server 172.17.14.3:8080 weight&#x3D;2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4、ip_hash:nginx会让相同的客户端ip请求相同的服务器。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;       server 172.17.14.3:8080;      ip_hash;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、nginx负载均衡配置状态参数</p><ul><li>down，表示当前的server暂时不参与负载均衡。</li><li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li><li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li><li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间单位秒。max_fails可以和fail_timeout一起使用。</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;      server 172.17.14.2:8080 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2;     server 172.17.14.3:8080 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;1;       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你像跟多更深入的了解 nginx 的负载均衡算法，nginx官方提供一些插件大家可以了解下。 </p><p>Nginx官方文档：<a href="http://nginx.org/en/docs/http/load_balancing.html">http://nginx.org/en/docs/http/load_balancing.html</a></p><h6 id="3、nginx配置7层协议及4层协议方法（扩展）"><a href="#3、nginx配置7层协议及4层协议方法（扩展）" class="headerlink" title="3、nginx配置7层协议及4层协议方法（扩展）"></a>3、nginx配置7层协议及4层协议方法（扩展）</h6><p>准备三台机器:</p><p>代理服务器配置本地host解析域名；</p><p>后端服务器两台，需安装nginx并将nginx服务启动</p><h6 id="——配置代理服务器的nginx配置文件-相对完整的配置-——"><a href="#——配置代理服务器的nginx配置文件-相对完整的配置-——" class="headerlink" title="——配置代理服务器的nginx配置文件(相对完整的配置)——"></a>——配置代理服务器的nginx配置文件(相对完整的配置)——</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">worker_processes  4;worker_rlimit_nofile 102400;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application&#x2F;octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs&#x2F;access.log  main;    sendfile        on;    keepalive_timeout  65;    gzip  on;    upstream testweb &#123;   代理服务器分组ip_hash;      server 10.0.105.199:80 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2s;   server 10.0.105.202:80 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2s;        &#125;    server &#123;        listen       80;        server_name  www.test.com;        charset utf-8;        #access_log  logs&#x2F;host.access.log  main;        location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;testweb;                proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        &#125;        error_page   500 502 503 504  &#x2F;50x.html;        location &#x3D; &#x2F;50x.html &#123;            root   html;        &#125;&#125;     upstream testapp &#123; server 10.0.105.202:8081 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2s;      server 10.0.105.199:8081 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2s;               &#125;     server &#123;listen    81;server_namewww.app.com;charset utf-8;#access_log  logs&#x2F;host.access.log  main;location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;testapp;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>浏览器测试访问:</p><p><a href="http://www.test.com/">http://www.test.com/</a></p><p><a href="http://www.app.com:81/">http://www.app.com:81/</a></p><p>202服务器yum安装的创建新的配置文件:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# cd &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;[root@nginx-server conf.d]# cp default.conf test.conf[root@nginx-server conf.d]# cat test.conf server &#123;    listen       80;    server_name  localhost;    location &#x2F; &#123;         root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;         index  index.html index.htm;    &#125;&#125;server &#123;    listen       8081;    server_name  localhost;    location &#x2F; &#123;         root   &#x2F;var&#x2F;www&#x2F;nginx&#x2F;html;         index  index.html index.htm;    &#125;&#125;[root@nginx-server ~]# nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nginx在1.9.0的时候，增加了一个 stream 模块，用来实现四层协议（网络层和传输层）的转发、代理、负载均衡等。stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#4层tcp负载 stream &#123;upstream myweb &#123;                hash $remote_addr consistent;                server 172.17.14.2:8080;                server 172.17.14.3:8080;        &#125;        server &#123;            listen 82;            proxy_connect_timeout 10s;            proxy_timeout 30s;            proxy_pass myweb;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>nginx 会话保持</strong></p><p>nginx会话保持主要有以下几种实现方式。</p><h5 id="1、ip-hash"><a href="#1、ip-hash" class="headerlink" title="1、ip_hash"></a><strong>1、ip_hash</strong></h5><p>ip_hash使用源地址哈希算法，将同一客户端的请求总是发往同一个后端服务器，除非该服务器不可用。</p><p>ip_hash语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream backend &#123;    ip_hash;    server backend1.example.com;    server backend2.example.com;    server backend3.example.com down;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ip_hash简单易用，但有如下问题：<br>当后端服务器宕机后，session会丢失；<br>来自同一局域网的客户端会被转发到同一个后端服务器，可能导致负载失衡；<br>不适用于CDN网络，不适用于前段还有代理的情况。</p><h5 id="2、sticky-cookie-insert"><a href="#2、sticky-cookie-insert" class="headerlink" title="2、sticky_cookie_insert"></a>2、sticky_cookie_insert</h5><p>使用sticky_cookie_insert启用会话亲缘关系，这会导致来自同一客户端的请求被传递到一组服务器的同一台服务器。与ip_hash不同之处在于，它不是基于IP来判断客户端的，而是基于cookie来判断。因此可以避免上述ip_hash中来自同一局域网的客户端和前段代理导致负载失衡的情况。(需要引入第三方模块才能实现)<br>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream backend &#123;    server backend1.example.com;    server backend2.example.com;    sticky_cookie_insert srv_id expires&#x3D;1h domain&#x3D;3evip.cn path&#x3D;&#x2F;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<br>expires：设置浏览器中保持cookie的时间<br>domain：定义cookie的域<br>path：为cookie定义路径</p><h5 id="3、jvm-route方式"><a href="#3、jvm-route方式" class="headerlink" title="3、jvm_route方式"></a><strong>3、jvm_route方式</strong></h5><p>　　jvm_route是通过session_cookie这种方式来实现session粘性。将特定会话附属到特定tomcat上，从而解决session不同步问题，但是无法解决宕机后会话转移问题。如果在cookie和url中并没有session，则这只是个简单的round-robin负载均衡。</p><p>　　jvm_route的原理</p><ul><li>一开始请求过来，没有带session的信息，jvm_route就根据round robin的方法，发到一台Tomcat上面</li><li>Tomcat添加上session信息，并返回给客户</li><li>用户再次请求，jvm_route看到session中有后端服务器的名称，他就把请求转到对应的服务器上</li></ul><p>　　暂时jvm_route模块还不支持fair的模式。jvm_route的工作模式和fair是冲突的。对于某个特定用户，当一直为他服务的Tomcat宕机后，默认情况下它会重试max_fails的次数，如果还是失败，就重新启用round robin的方式，而这种情况下就会导致用户的session丢失。</p><p><strong>4、使用后端服务器自身通过相关机制保持session同步，如：使用数据库、redis、memcached 等做session复制</strong></p><h3 id="nginx-实现动静分离"><a href="#nginx-实现动静分离" class="headerlink" title="nginx 实现动静分离"></a>nginx 实现动静分离</h3><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 在动静分离的tomcat的时候比较明显，因为tomcat解析静态很慢，其实这些原理的话都很好理解，简单来说，就是使用正则表达式匹配过滤，然后交个不同的服务器。</p><p><strong>1、准备环境</strong></p><p>准备一个nginx代理 两个http 分别处理动态和静态。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1.配置nginx反向代理upstream；upstream static &#123;        server 10.0.105.196:80 weight&#x3D;1 max_fails&#x3D;1 fail_timeout&#x3D;60s;        &#125;upstream php &#123;        server 10.0.105.200:80 weight&#x3D;1 max_fails&#x3D;1 fail_timeout&#x3D;60s;        &#125;     server &#123;        listen      80;        server_name     localhost;        #动态资源加载        location ~ \.(php|jsp)$ &#123;            proxy_pass http:&#x2F;&#x2F;php;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                &#125;        #静态资源加载        location ~ .*\.(html|gif|jpg|png|bmp|swf|css|js)$ &#123;            proxy_pass http:&#x2F;&#x2F;static;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                &#125;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">静态资源配置server &#123;        listen 80;        server_name     localhost;        location ~ \.(html|jpg|png|js|css|gif|bmp|jpeg) &#123;        root &#x2F;home&#x2F;www&#x2F;nginx;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">动态资源配置:yum 安装php7.1[root@nginx-server ~]#rpm -Uvh https:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el7&#x2F;epel-release.rpm[root@nginx-server ~]#rpm -Uvh https:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el7&#x2F;webtatic-release.rpm[root@nginx-server ~]#yum install php71w-xsl php71w php71w-ldap php71w-cli php71w-common php71w-devel php71w-gd php71w-pdo php71w-mysql php71w-mbstring php71w-bcmath php71w-mcrypt -y[root@nginx-server ~]#yum install -y php71w-fpm[root@nginx-server ~]#systemctl start php-fpm[root@nginx-server ~]#systemctl enable php-fpm编辑nginx的配置文件:server &#123;        listen      80;        server_name     localhost;        location ~ \.php$ &#123;            root           &#x2F;home&#x2F;nginx&#x2F;html;  #指定网站目录            fastcgi_pass   127.0.0.1:9000;    #指定访问地址            fastcgi_index  index.php;#指定默认文件            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name; #站点根目录，取决于root配置项            include        fastcgi_params;  #包含nginx常量定义        &#125;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当访问静态页面的时候location 匹配到 (html|jpg|png|js|css|gif|bmp|jpeg) 通过转发到静态服务器，静态服务通过location的正则匹配来处理请求。</p><p>当访问动态页面时location匹配到 .php 结尾的文件转发到后端php服务处理请求。</p><h3 id><a href="#" class="headerlink" title></a></h3><h6 id="-1"><a href="#-1" class="headerlink" title></a></h6>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 反向代理 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx编译安装</title>
      <link href="/2021/08/13/nginx/nginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
      <url>/2021/08/13/nginx/nginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="1、nginx-编译安装与配置使用"><a href="#1、nginx-编译安装与配置使用" class="headerlink" title="1、nginx 编译安装与配置使用"></a>1、nginx 编译安装与配置使用</h3><h5 id="1、安装编译环境"><a href="#1、安装编译环境" class="headerlink" title="1、安装编译环境"></a>1、安装编译环境</h5><p><code>yum -y install gcc gcc-c++</code></p><h5 id="2、安装pcre软件包（使nginx支持http-rewrite模块）"><a href="#2、安装pcre软件包（使nginx支持http-rewrite模块）" class="headerlink" title="2、安装pcre软件包（使nginx支持http rewrite模块）"></a>2、安装pcre软件包（使nginx支持http rewrite模块）</h5><p><code>yum install -y pcre pcre-devel</code></p><h5 id="3、安装openssl-devel（使nginx支持ssl）"><a href="#3、安装openssl-devel（使nginx支持ssl）" class="headerlink" title="3、安装openssl-devel（使nginx支持ssl）"></a>3、安装openssl-devel（使nginx支持ssl）</h5><p><code>yum install -y openssl openssl-devel </code></p><h5 id="4、安装zlib"><a href="#4、安装zlib" class="headerlink" title="4、安装zlib"></a>4、安装zlib</h5><p><code>yum install -y zlib zlib-devel</code></p><h5 id="5、创建用户nginx"><a href="#5、创建用户nginx" class="headerlink" title="5、创建用户nginx"></a>5、创建用户nginx</h5><p><code>useradd nginx </code></p><p><code>passwd nginx</code>  （系统用户不给予密码更安全）</p><p><strong>6、安装nginx</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost ~]# wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.0.tar.gz[root@localhost ~]# tar xzf nginx-1.16.0.tar.gz -C &#x2F;usr&#x2F;local&#x2F;[root@localhost ~]# cd nginx-1.16.0[root@localhost ~]# wget https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;echo-nginx-module&#x2F;archive&#x2F;v0.61.tar.gz      # 此处为下载一个echo-nginx-module模块，可实现在nginx配置文件中使用echo打印，辅助排错，可不装[root@localhost ~]# tar xf v0.61.tar.gz[root@localhost nginx-1.16.0]# .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --group&#x3D;nginx --user&#x3D;nginx --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --http-client-body-temp-path&#x3D;&#x2F;tmp&#x2F;nginx&#x2F;client_body --http-proxy-temp-path&#x3D;&#x2F;tmp&#x2F;nginx&#x2F;proxy --http-fastcgi-temp-path&#x3D;&#x2F;tmp&#x2F;nginx&#x2F;fastcgi --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream[root@localhost nginx-1.16.0]# make &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>7、Nginx 编译参数</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看 nginx 安装的模块[root@localhost ~]#&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V# 模块参数具体功能 --with-cc-opt&#x3D;&#39;-g -O2 -fPIE -fstack-protector    &#x2F;&#x2F;设置额外的参数将被添加到CFLAGS变量。（FreeBSD或者ubuntu使用）--param&#x3D;ssp-buffer-size&#x3D;4 -Wformat -Werror&#x3D;format-security -D_FORTIFY_SOURCE&#x3D;2&#39; --with-ld-opt&#x3D;&#39;-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now&#39; --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx                        &#x2F;&#x2F;指向安装目录--conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf                &#x2F;&#x2F;指定配置文件--http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log        &#x2F;&#x2F;指定访问日志--error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log        &#x2F;&#x2F;指定错误日志--lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock                 &#x2F;&#x2F;指定lock文件--pid-path&#x3D;&#x2F;run&#x2F;nginx.pid                        &#x2F;&#x2F;指定pid文件--http-client-body-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;body    &#x2F;&#x2F;设定http客户端请求临时文件路径--http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;fastcgi     &#x2F;&#x2F;设定http fastcgi临时文件路径--http-proxy-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;proxy         &#x2F;&#x2F;设定http代理临时文件路径--http-scgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;scgi           &#x2F;&#x2F;设定http scgi临时文件路径--http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;uwsgi         &#x2F;&#x2F;设定http uwsgi临时文件路径--with-debug                                        &#x2F;&#x2F;启用debug日志--with-pcre-jit                                     &#x2F;&#x2F;编译PCRE包含“just-in-time compilation”--with-ipv6                                         &#x2F;&#x2F;启用ipv6支持--with-http_ssl_module                              &#x2F;&#x2F;启用ssl支持--with-http_stub_status_module                      &#x2F;&#x2F;获取nginx自上次启动以来的状态--with-http_realip_module                 &#x2F;&#x2F;允许从请求标头更改客户端的IP地址值，默认为关--with-http_auth_request_module           &#x2F;&#x2F;实现基于一个子请求的结果的客户端授权。如果该子请求返回的2xx响应代码，所述接入是允许的。如果它返回401或403中，访问被拒绝与相应的错误代码。由子请求返回的任何其他响应代码被认为是一个错误。--with-http_addition_module               &#x2F;&#x2F;作为一个输出过滤器，支持不完全缓冲，分部分响应请求--with-http_dav_module                    &#x2F;&#x2F;增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法 默认关闭，需编译开启--with-http_geoip_module                  &#x2F;&#x2F;使用预编译的MaxMind数据库解析客户端IP地址，得到变量值--with-http_gunzip_module                 &#x2F;&#x2F;它为不支持“gzip”编码方法的客户端解压具有“Content-Encoding: gzip”头的响应。--with-http_gzip_static_module            &#x2F;&#x2F;在线实时压缩输出数据流--with-http_image_filter_module           &#x2F;&#x2F;传输JPEG&#x2F;GIF&#x2F;PNG 图片的一个过滤器）（默认为不启用。gd库要用到）--with-http_spdy_module                   &#x2F;&#x2F;SPDY可以缩短网页的加载时间--with-http_sub_module                    &#x2F;&#x2F;允许用一些其他文本替换nginx响应中的一些文本--with-http_xslt_module                   &#x2F;&#x2F;过滤转换XML请求--with-mail                               &#x2F;&#x2F;启用POP3&#x2F;IMAP4&#x2F;SMTP代理模块支持--with-mail_ssl_module                    &#x2F;&#x2F;启用ngx_mail_ssl_module支持启用外部模块支持<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>8、修改配置文件/etc/nginx/nginx.conf</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 全局参数设置 worker_processes  4;          #设置nginx启动进程的数量，一般设置成与逻辑cpu数量相同 error_log  logs&#x2F;error.log;    #指定错误日志 worker_rlimit_nofile 102400;  #设置一个nginx进程能打开的最大文件数 pid        &#x2F;var&#x2F;run&#x2F;nginx.pid; #nginx开启后会在&#x2F;var&#x2F;run&#x2F;下生成nginx.pid:include &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;modules&#x2F;*.conf;   # include 目录下的子配置文件继承主配置文件events &#123;     worker_connections  1024; #设置一个进程的最大并发连接数 &#125;# http 服务相关设置 http &#123;     include      mime.types;     default_type  application&#x2F;octet-stream;     log_format  main  &#39;remote_addr - remote_user [time_local] &quot;request&quot; &#39;                      &#39;status body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;http_user_agent&quot; &quot;http_x_forwarded_for&quot;&#39;;     access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;    #设置访问日志的位置和格式     sendfile          on; #是否调用sendfile函数输出文件，一般设置为on，若nginx是用来进行磁盘IO负载应用时，可以设置为off，降低系统负载     gzip              on;      #是否开启gzip压缩，将注释去掉开启     keepalive_timeout  65;     #设置长连接的超时时间# 虚拟服务器的相关设置 include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;   # include 在&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;下，任意以.conf结尾的配置文件均等效在该模块内可生                                                   效，如下方的 server&#123;&#125;   以及server下的location&#123;&#125;        server &#123;         listen      80;        #设置监听的端口         server_name  localhost;        #设置绑定的主机名、域名或ip地址         charset koi8-r;        # 设置编码字符         location &#x2F; &#123;             root  &#x2F;var&#x2F;www&#x2F;nginx;           #设置服务器默认网站的根目录位置,需要手动创建            index  index.html index.htm;    #设置默认打开的文档             &#125;         error_page  500 502 503 504  &#x2F;50x.html; #设置错误信息返回页面         location &#x3D; &#x2F;50x.html &#123;             root  html;        #这里的绝对位置是&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html        &#125;     &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx.conf的组成:nginx.conf一共由三部分组成，分别为：全局块、events块、http块。在http块中又包含http全局块、多个server块。每个server块中又包含server全局块以及多个location块。在统一配置块中嵌套的配置快，各个之间不存在次序关系。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>检测nginx配置文件是否正确</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t[root@localhost ~]# mkdir -p &#x2F;tmp&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>10、启动nginx服务</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>11、通过 nginx 命令控制 nginx 服务</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx -c &#x2F;path&#x2F;nginx.conf       # 以特定目录下的配置文件启动nginx:nginx -s reload              # 修改配置后重新加载生效nginx -s reopen     # 重新打开日志文件nginx -s stop    # 快速停止nginxnginx -s quit     # 完整有序的停止nginxnginx -t     # 测试当前配置文件是否正确nginx -t -c &#x2F;path&#x2F;to&#x2F;nginx.conf  # 测试特定的nginx配置文件是否正确注意：nginx -s reload 命令加载修改后的配置文件,命令下达后发生如下事件1. Nginx的master进程检查配置文件的正确性，若是错误则返回错误信息，nginx继续采用原配置文件进行工作（因为worker未受到影响）2. Nginx启动新的worker进程，采用新的配置文件3. Nginx将新的请求分配新的worker进程4. Nginx等待以前的worker进程的全部请求已经都返回后，关闭相关worker进程5. 重复上面过程，知道全部旧的worker进程都被关闭掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>12、实现nginx开机自启</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost ~]# vim &#x2F;etc&#x2F;init.d&#x2F;nginx#!&#x2F;bin&#x2F;sh # # nginx - this script starts and stops the nginx daemon # # chkconfig:  - 85 15  # description:  Nginx is an HTTP(S) server, HTTP(S) reverse \ #              proxy and IMAP&#x2F;POP3 proxy server # processname: nginx # config:      &#x2F;etc&#x2F;nginx&#x2F;nginx.conf # config:      &#x2F;etc&#x2F;sysconfig&#x2F;nginx # pidfile:    &#x2F;var&#x2F;run&#x2F;nginx.pid   # Source function library. . &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions  # Source networking configuration. . &#x2F;etc&#x2F;sysconfig&#x2F;network  # Check that networking is up. [ &quot;$NETWORKING&quot; &#x3D; &quot;no&quot; ] &amp;&amp; exit 0   nginx&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;prog&#x3D;$(basename $nginx)   NGINX_CONF_FILE&#x3D;&quot;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&quot;  [ -f &#x2F;etc&#x2F;sysconfig&#x2F;nginx ] &amp;&amp; . &#x2F;etc&#x2F;sysconfig&#x2F;nginx  lockfile&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx  make_dirs() &#123;   # make required directories   user&#x3D;&#96;nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &#39;s&#x2F;[^*]*--user&#x3D;\([^ ]*\).*&#x2F;\1&#x2F;g&#39; -&#96;   options&#x3D;&#96;$nginx -V 2&gt;&amp;1 | grep &#39;configure arguments:&#39;&#96;   for opt in $options; do      if [ &#96;echo $opt | grep &#39;.*-temp-path&#39;&#96; ]; then          value&#x3D;&#96;echo $opt | cut -d &quot;&#x3D;&quot; -f 2&#96;           if [ ! -d &quot;$value&quot; ]; then              # echo &quot;creating&quot; $value               mkdir -p $value &amp;&amp; chown -R $user $value           fi      fi  done&#125;   start() &#123;     [ -x $nginx ] || exit 5     [ -f $NGINX_CONF_FILE ] || exit 6     make_dirs     echo -n $&quot;Starting $prog: &quot;    daemon $nginx -c $NGINX_CONF_FILE     retval&#x3D;$?     echo    [ $retval -eq 0 ] &amp;&amp; touch $lockfile     return $retval &#125;   stop() &#123;     echo -n $&quot;Stopping $prog: &quot;    killproc $prog -QUIT     retval&#x3D;$?     echo    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile     return $retval &#125;   restart() &#123;     configtest || return $?     stop     sleep 1     start &#125;   reload() &#123;     configtest || return $?     echo -n $&quot;Reloading $prog: &quot;    killproc $nginx -HUP     RETVAL&#x3D;$?     echo&#125;   force_reload() &#123;     restart &#125;   configtest() &#123;   $nginx -t -c $NGINX_CONF_FILE &#125;   rh_status() &#123;     status $prog &#125;   rh_status_q() &#123;     rh_status &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &#125;   case &quot;$1&quot; in    start)         rh_status_q &amp;&amp; exit 0         $1         ;;     stop)         rh_status_q || exit 0         $1         ;;     restart|configtest)         $1         ;;     reload)         rh_status_q || exit 7         $1         ;;     force-reload)         force_reload         ;;     status)         rh_status         ;;     condrestart|try-restart)         rh_status_q || exit 0             ;;     *)         echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot;        exit 2 esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b、添加权限</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chmod +x &#x2F;etc&#x2F;init.d&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>c、重新加载系统启动文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>d、启动并设置开机自启</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl start nginx[root@localhost ~]# &#x2F;sbin&#x2F;chkconfig nginx on ---开机启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 编译安装 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
