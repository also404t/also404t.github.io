<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nginx平滑升级</title>
      <link href="/2021/08/14/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/"/>
      <url>/2021/08/14/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx-的平滑升级"><a href="#nginx-的平滑升级" class="headerlink" title="nginx 的平滑升级"></a>nginx 的平滑升级</h1><h3 id="1、为什么要对-nginx-平滑升级"><a href="#1、为什么要对-nginx-平滑升级" class="headerlink" title="1、为什么要对 nginx 平滑升级"></a>1、为什么要对 nginx 平滑升级</h3><p>  随着 <code>nginx</code> 越来越流行，并且 <code>nginx</code> 的优势也越来越明显，<code>nginx</code> 的版本迭代也来时加速模式，1.9.0版本的nginx更新了许多新功能，例如 <code>stream</code> 四层代理功能，伴随着 <code>nginx</code> 的广泛应用，版本升级必然越来越快，线上业务不能停，此时 <code>nginx</code> 的升级就是运维的工作了</p><p>  nginx 方便地帮助我们实现了平滑升级。其原理简单概括，就是：<br>  （1）在不停掉老进程的情况下，启动新进程。<br>  （2）老进程负责处理仍然没有处理完的请求，但不再接受处理请求。<br>  （3）新进程接受新请求。<br>  （4）老进程处理完所有请求，关闭所有连接后，停止。<br>  这样就很方便地实现了平滑升级。一般有两种情况下需要升级 nginx，一种是确实要升级 nginx 的版本，另一种是要为 nginx 添加新的模块。</p><h3 id="2、nginx-平滑升级原理"><a href="#2、nginx-平滑升级原理" class="headerlink" title="2、nginx 平滑升级原理"></a>2、nginx 平滑升级原理</h3><p>  <strong>多进程模式下的请求分配方式</strong></p><p>  nginx 默认工作在多进程模式下，即主进程（master process）启动后完成配置加载和端口绑定等动作，<code>fork</code>出指定数量的工作进程（worker process），这些子进程会持有监听端口的文件描述符（fd），并通过在该描述符上添加监听事件来接受连接（accept）。</p><p>  <strong>信号的接收和处理</strong></p><p>  nginx 主进程在启动完成后会进入等待状态，负责响应各类系统消息，如SIGCHLD、SIGHUP、SIGUSR2等。</p><p>  <strong>Nginx信号简介</strong></p><p>  <strong>主进程支持的信号</strong></p><ul><li><code>TERM</code>, <code>INT</code>: 立刻退出</li><li><code>QUIT</code>: 等待工作进程结束后再退出</li><li><code>KILL</code>: 强制终止进程</li><li><code>HUP</code>: 重新加载配置文件，使用新的配置启动工作进程，并逐步关闭旧进程。</li><li><code>USR1</code>: 重新打开日志文件</li><li><code>USR2</code>: 启动新的主进程，实现热升级</li><li><code>WINCH</code>: 逐步关闭工作进程</li></ul><p>  <strong>工作进程支持的信号</strong></p><ul><li><code>TERM</code>, <code>INT</code>: 立刻退出</li><li><code>QUIT</code>: 等待请求处理结束后再退出</li><li><code>USR1</code>: 重新打开日志文件</li></ul><h3 id="3、nginx-平滑升级实战"><a href="#3、nginx-平滑升级实战" class="headerlink" title="3、nginx 平滑升级实战"></a>3、nginx 平滑升级实战</h3><p>1、查看现有的 nginx 编译参数</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、编译  </p><p>按照原来的编译参数安装 nginx 的方法进行安装，<strong>只需要到 make，千万不要 make install</strong> 。如果make install 会将原来的配置文件覆盖</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# cd &#x2F;usr&#x2F;local&#x2F;nginx-1.16.0&#x2F;[root@nginx-server nginx-1.16.0]# .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --group&#x3D;nginx --user&#x3D;nginx --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --http-client-body-temp-path&#x3D;&#x2F;tmp&#x2F;nginx&#x2F;client_body --http-proxy-temp-path&#x3D;&#x2F;tmp&#x2F;nginx&#x2F;proxy --http-fastcgi-temp-path&#x3D;&#x2F;tmp&#x2F;nginx&#x2F;fastcgi --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream --with-http_image_filter_module[root@nginx-server nginx-1.16.0]# make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、备份原 nginx 二进制文件</p><p>  备份二进制文件和 nginx 的配置文件（期间nginx不会停止服务）</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server nginx-1.16.0]# mv &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx_$(date +%F)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、复制新的nginx二进制文件，进入新的nginx源码包</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server nginx-1.16.0]# cp &#x2F;usr&#x2F;local&#x2F;nginx-1.16.0&#x2F;objs&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5、测试新版本的nginx是否正常</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server nginx-1.16.0]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6、给nginx发送平滑迁移信号（若不清楚pid路径，请查看nginx配置文件）</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# kill -USR2 &#96;cat &#x2F;var&#x2F;run&#x2F;nginx.pid&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7、查看nginx pid，会出现一个nginx.pid.oldbin</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# ll &#x2F;var&#x2F;run&#x2F;nginx.pid*-rw-r--r-- 1 root root 5 Jul  1 11:29 &#x2F;var&#x2F;run&#x2F;nginx.pid-rw-r--r-- 1 root root 5 Jul  1 09:54 &#x2F;var&#x2F;run&#x2F;nginx.pid.oldbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>8、从容关闭旧的Nginx进程</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# kill -WINCH &#96;cat &#x2F;var&#x2F;run&#x2F;nginx.pid.oldbin&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9、此时不重载配置启动旧的工作进程</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# kill -HUP &#96;cat &#x2F;var&#x2F;run&#x2F;nginx.pid.oldbin&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>10、结束工作进程，完成此次升级</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# kill -QUIT &#96;cat &#x2F;var&#x2F;run&#x2F;nginx.pid.oldbin&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>11、验证Nginx是否升级成功</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、升级实验"><a href="#4、升级实验" class="headerlink" title="4、升级实验"></a>4、升级实验</h3><p>  <strong>1、安装配置1.6版本的 nginx</strong></p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost ~]# yum install -y gcc gcc-c++ pcre-devel openssl-devel zlib-devel[root@localhost ~]# tar xzf nginx-1.6.3.tar.gz -C &#x2F;usr&#x2F;local&#x2F;[root@localhost ~]# cd &#x2F;usr&#x2F;local&#x2F;nginx-1.6.3[root@localhost nginx-1.6.3]# .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --user&#x3D;nginx --group&#x3D;nginx --with-http_stub_status_module[root@localhost nginx-1.6.3]# make &amp;&amp; make install[root@localhost nginx-1.6.3]# useradd -M -s &#x2F;sbin&#x2F;nologin nginx[root@localhost nginx-1.6.3]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t nginx: the configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf test is successful[root@localhost nginx-1.6.3]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx [root@localhost nginx-1.6.3]# netstat -lntpProto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name    tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      13989&#x2F;nginx: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>2、查看版本和模块</strong></p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost nginx-1.6.3]# &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V nginx version: nginx&#x2F;1.6.3built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) configure arguments: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --user&#x3D;nginx --group&#x3D;nginx --with-http_stub_status_module[root@localhost nginx-1.6.3]# echo &quot;nginx1.6&quot; &gt; &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.html[root@localhost nginx-1.6.3]# yum install -y elinks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>4、访问验证</strong></p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost nginx-1.6.3]# elinks 10.0.105.189<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  <strong>5、升级nginx</strong></p><p>  将 nginx 版本进行升级 并在不影响业务的情况下添加 SSL 和 pcre 模块</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost ~]# tar xzf nginx-1.12.2.tar.gz -C &#x2F;usr&#x2F;local&#x2F;[root@localhost ~]# cd &#x2F;usr&#x2F;local&#x2F;nginx-1.12.2&#x2F;[root@localhost nginx-1.12.2]# .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --user&#x3D;nginx --group&#x3D;ngiinx --with-http_stub_status_module --with-http_ssl_module --with-pcre[root@localhost nginx-1.12.2]# make[root@localhost nginx-1.12.2]# cd[root@localhost ~]# mv &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx_lod[root@localhost ~]# cp &#x2F;usr&#x2F;local&#x2F;nginx-1.12.2&#x2F;objs&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;[root@localhost ~]# mv &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf.bak[root@localhost ~]# kill -USR2 &#96;cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#96;[root@localhost ~]# ls &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log  error.log  nginx.pid[root@localhost ~]# ps aux | grep nginx root      13989  0.0  0.0  24860   952 ?        Ss   13:55   0:00 nginx: master process &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginxnginx     13990  0.0  0.1  25284  1720 ?        S    13:55   0:00 nginx: worker processroot      16525  0.0  0.0 112708   976 pts&#x2F;2    S+   14:09   0:00 grep --color&#x3D;auto nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 平滑升级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx日志配置</title>
      <link href="/2021/08/14/nginx/nginx%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/08/14/nginx/nginx%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1、nginx-日志配置"><a href="#1、nginx-日志配置" class="headerlink" title="1、nginx 日志配置"></a>1、nginx 日志配置</h1><h3 id="1、nginx-日志介绍"><a href="#1、nginx-日志介绍" class="headerlink" title="1、nginx 日志介绍"></a>1、nginx 日志介绍</h3><p><code>nginx</code> 有一个非常灵活的日志记录模式,每个级别的配置可以有各自独立的访问日志, 所需日志模块 <code>ngx_http_log_module</code> 的支持，日志格式通过 <code>log_format</code> 命令来定义，日志对于统计和排错是非常有利的，下面总结了 <code>nginx</code> 日志相关的配置 包括 <code>access_log</code>、<code>log_format</code>、<code>open_log_file_cache</code>、<code>log_not_found</code>、<code>log_subrequest</code>、<code>rewrite_log</code>、<code>error_log</code>。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 设置访问日志access_log path [format [buffer&#x3D;size] [gzip[&#x3D;level]] [flush&#x3D;time] [if&#x3D;condition]];# 关闭访问日志access_log off; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>path</strong> 指定日志的存放位置。</li><li><strong>format</strong> 指定日志的格式。默认使用预定义的<code>combined</code>。</li><li><strong>buffer</strong> 用来指定日志写入时的缓存大小。默认是64k。</li><li><strong>gzip</strong> 日志写入前先进行压缩。压缩率可以指定，从1到9数值越大压缩比越高，同时压缩的速度也越慢。默认是1。</li><li><strong>flush</strong> 设置缓存的有效时间。如果超过flush指定的时间，缓存中的内容将被清空。</li><li><strong>if</strong> 条件判断。如果指定的条件计算为0或空字符串，那么该请求不会写入日志。</li></ul><p><strong>作用域：</strong></p><p>可以应用<code>access_log</code>指令的作用域分别有<code>http</code>，<code>server</code>，<code>location</code>，<code>limit_except</code>。也就是说，在这几个作用域外使用该指令，Nginx会报错。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">access_log &#x2F;var&#x2F;logs&#x2F;nginx-access.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该例子指定日志的写入路径为<code>/var/logs/nginx-access.log</code>，日志格式使用默认的<code>combined</code>。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">access_log &#x2F;var&#x2F;logs&#x2F;nginx-access.log buffer&#x3D;32k gzip flush&#x3D;1m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该例子指定日志的写入路径为<code>/var/logs/nginx-access.log</code>，日志格式使用默认的<code>combined</code>，指定日志的缓存大小为 32k，日志写入前启用 gzip 进行压缩，压缩比使用默认值 1，缓存数据有效时间为1分钟。</p><h3 id="2、log-format-指令"><a href="#2、log-format-指令" class="headerlink" title="2、log_format 指令"></a>2、log_format 指令</h3><p>Nginx 预定义了名为 <code>combined</code> 日志格式，如果没有明确指定日志格式默认使用该格式：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">log_format combined &#39;$remote_addr - $remote_user [$time_local] &#39;                    &#39;&quot;$request&quot; $status $body_bytes_sent &#39;                    &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果不想使用Nginx预定义的格式，可以通过<code>log_format</code>指令来自定义。</p><p>语法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">log_format name [escape&#x3D;default|json] string ...;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>name</strong> 格式名称。在 access_log 指令中引用。</li><li><strong>escape</strong> 设置变量中的字符编码方式是<code>json</code>还是<code>default</code>，默认是<code>default</code>。</li><li><strong>string</strong> 要定义的日志格式内容。该参数可以有多个。参数中可以使用Nginx变量。</li></ul><p><code>log_format</code> 指令中常用的一些变量：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$remote_addr, $http_x_forwarded_for   #记录客户端IP地址$remote_user                    #记录客户端用户名称$request                   #记录请求的URL和HTTP协议$status                     #记录请求状态$body_bytes_sent      #发送给客户端的字节数，不包括响应头的大小$bytes_sent               #发送给客户端的总字节数$http_referer            #记录从哪个页面链接访问过来的,可以根据该参数进行防盗链设置$http_user_agent      #记录客户端浏览器相关信息$time_local               #通用日志格式下的本地时间。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义日志格式的使用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">access_log &#x2F;var&#x2F;logs&#x2F;nginx-access.log mainlog_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>log_format</code>指令定义了一个<code>main</code>的格式，并在<code>access_log</code>指令中引用了它。假如客户端有发起请求：<code>https://qf.com/</code>，我们看一下我截取的一个请求的日志记录:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">10.0.105.207 - - [01&#x2F;Jul&#x2F;2019:10:44:36 +0800] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.100 Safari&#x2F;537.36&quot; &quot;-&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们看到最终的日志记录中<code>$remote_user</code>、<code>$http_referer</code>、<code>$http_x_forwarded_for</code>都对应了一个<code>-</code>，这是因为这几个变量为空。</p><p>   <strong>面试时：注意日志里面的ip地址一定要在第一列。</strong>    </p><h3 id="3、error-log-指令"><a href="#3、error-log-指令" class="headerlink" title="3、error_log 指令"></a>3、error_log 指令</h3><p>错误日志在Nginx中是通过<code>error_log</code>指令实现的。该指令记录服务器和请求处理过程中的错误信息。</p><p><strong>语法</strong></p><p>配置错误日志文件的路径和日志级别。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">error_log file [level];Default:error_log logs&#x2F;error.log error;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>file</code> 参数指定日志的写入位置。</p><p><code>level</code> 参数指定日志的级别。level可以是<code>debug</code>, <code>info</code>, <code>notice</code>, <code>warn</code>, <code>error</code>, <code>crit</code>, <code>alert</code>,<code>emerg</code>中的任意值。可以看到其取值范围是按紧急程度从低到高排列的。只有日志的错误级别等于或高于level指定的值才会写入错误日志中。默认值是<code>error</code>。</p><p><strong>基本用法</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">error_log &#x2F;var&#x2F;logs&#x2F;nginx&#x2F;nginx-error.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置段：<code>main</code>， <code>http</code>,  <code>mail</code>,  <code>stream</code>,  <code>server</code>, <code>location</code>作用域。</p><p>例子中指定了错误日志的路径为：<code>/var/logs/nginx/nginx-error.log</code>，日志级别使用默认的 <code>error</code>。</p><h3 id="4、open-log-file-cache-指令"><a href="#4、open-log-file-cache-指令" class="headerlink" title="4、open_log_file_cache 指令"></a>4、open_log_file_cache 指令</h3><p>每一条日志记录的写入都是先打开文件再写入记录，然后关闭日志文件。如果你的日志文件路径中使用了变量，如  <code>access_log /var/logs/$host/nginx-access.log</code>，为提高性能，可以使用<code>open_log_file_cache</code>指令设置日志文件描述符的缓存。</p><p><strong>语法</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">open_log_file_cache max&#x3D;N [inactive&#x3D;time] [min_uses&#x3D;N] [valid&#x3D;time];默认值: open_log_file_cache off;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>max</strong> 设置缓存中最多容纳的文件描述符数量，如果被占满，采用LRU算法将描述符关闭。</p></li><li><p><strong>inactive</strong> 设置缓存存活时间，默认是10s。</p></li><li><p><strong>min_uses</strong> 在<strong>inactive</strong>时间段内，日志文件最少使用几次，该日志文件描述符记入缓存，默认是1次。</p></li><li><p><strong>valid</strong>：设置多久对日志文件名进行检查，看是否发生变化，默认是60s。</p></li><li><p><strong>off</strong>：不使用缓存。默认为off。</p><p><strong>基本用法</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">open_log_file_cache max&#x3D;1000 inactive&#x3D;20s valid&#x3D;1m min_uses&#x3D;2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置段:<code>http</code>、<code>server</code>、<code>location</code>作用域中。</p><p>例子中，设置缓存最多缓存1000个日志文件描述符，20s内如果缓存中的日志文件描述符至少被被访问2次，才不会被缓存关闭。每隔1分钟检查缓存中的文件描述符的文件名是否还存在。</p></li></ul><h3 id="5、log-not-found-指令"><a href="#5、log-not-found-指令" class="headerlink" title="5、log_not_found 指令"></a>5、log_not_found 指令</h3><p>  是否在<code>error_log</code>中记录不存在的错误。默认是</p><p>  <strong>基本语法:</strong> </p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">log_not_found on | off;默认值: log_not_found on;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  配置段: <code>http</code>, <code>server</code>, <code>location</code>作用域。</p><h3 id="6、log-subrequest-指令"><a href="#6、log-subrequest-指令" class="headerlink" title="6、log_subrequest 指令"></a>6、log_subrequest 指令</h3><p>  是否在<code>access_log</code>中记录子请求的访问日志。默认不记录</p><p>  <strong>基本语法</strong></p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">log_subrequest on | off;默认值: log_subrequest off;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  配置段:  <code>http</code>, <code> server</code>, <code>location</code>作用域。</p><h3 id="7、rewrite-log-指令"><a href="#7、rewrite-log-指令" class="headerlink" title="7、rewrite_log 指令"></a>7、rewrite_log 指令</h3><p>  由<code>ngx_http_rewrite_module</code>模块提供的。用来记录重写日志的。对于调试重写规则建议开启，启用时将在<code>error log</code>中记录<code>notice</code>级别的重写日志。<br>  <strong>基本语法:</strong> </p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rewrite_log on | off;默认值: rewrite_log off;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  配置段:  <code>http</code>,  <code>server</code>, <code>location</code>,  <code>if</code>作用域。</p><h3 id="8、nginx-日志配置总结"><a href="#8、nginx-日志配置总结" class="headerlink" title="8、nginx 日志配置总结"></a>8、nginx 日志配置总结</h3><p>  Nginx中通过<code>access_log</code>和<code>error_log</code>指令配置访问日志和错误日志，通过<code>log_format</code>我们可以自定义日志格式。如果日志文件路径中使用了变量，我们可以通过<code>open_log_file_cache</code> 指令来设置缓存，提升性能。其他的根据自己的使用场景定义。</p><p>  详细的日志配置信息可以参考<a href="https://link.juejin.im/?target=http://nginx.org/en/docs/varindex.html">Nginx官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx地址重写及location配置</title>
      <link href="/2021/08/14/nginx/nginx%E5%9C%B0%E5%9D%80%E9%87%8D%E5%86%99%E5%8F%8Alocation%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/08/14/nginx/nginx%E5%9C%B0%E5%9D%80%E9%87%8D%E5%86%99%E5%8F%8Alocation%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1、nginx-地址重写-rewrite"><a href="#1、nginx-地址重写-rewrite" class="headerlink" title="1、nginx 地址重写 rewrite"></a>1、nginx 地址重写 rewrite</h3><h5 id="1、什么是Rewrite"><a href="#1、什么是Rewrite" class="headerlink" title="1、什么是Rewrite"></a>1、什么是Rewrite</h5><pre><code>Rewrite对称URL Rewrite，即URL重写，就是把传入Web的请求重定向到其他URL的过程。</code></pre><ul><li>URL Rewrite最常见的应用是URL伪静态化，是将动态页面显示为静态页面方式的一种技术。比如<br><a href="http://www.123.com/news/index.php?id=123">http://www.123.com/news/index.php?id=123</a> 使用URLRewrite 转换后可以显示为 <a href="http://www.123/">http://www.123</a> .com/news/123.html对于追求完美主义的网站设计师，就算是网页的地址也希望看起来尽量简洁明快。<br>理论上，搜索引擎更喜欢静态页面形式的网页，搜索引擎对静态页面的评分一般要高于动态页面。所以，UrlRewrite可以让我们网站的网页更容易被搜索引擎所收录。</li><li>从安全角度上讲，如果在URL中暴露太多的参数，无疑会造成一定量的信息泄漏，可能会被一些黑客<br>利用，对你的系统造成一定的破坏，所以静态化的URL地址可以给我们带来更高的安全性。</li><li>实现网站地址跳转，例如用户访问360buy.com，将其跳转到jd.com。例如当用户访问tianyun.com的<br>80端口时，将其跳转到443端口。</li><li>重写之后的url更为简洁美观</li></ul><h5 id="2、Rewrite-相关指令"><a href="#2、Rewrite-相关指令" class="headerlink" title="2、Rewrite 相关指令"></a>2、Rewrite 相关指令</h5><ul><li><strong>Nginx Rewrite 相关指令有 if 、rewrite、set、return</strong></li></ul><h6 id="2-1、if-语句"><a href="#2-1、if-语句" class="headerlink" title="2.1、if 语句"></a>2.1、if 语句</h6><ul><li><p>应用环境</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server，location<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if (condition) &#123; … &#125;if 可以支持如下条件判断匹配符号~ 正则匹配 (区分大小写)~*     正则匹配 (不区分大小写)!~                  正则不匹配 (区分大小写)!~*            正则不匹配  (不区分大小写)-f 和!-f     用来判断是否存在文件-d 和!-d     用来判断是否存在目录-e 和!-e     用来判断是否存在文件或目录-x 和!-x     用来判断文件是否可执行在匹配过程中可以引用一些Nginx的全局变量$args请求中的参数;$document_root    针对当前请求的根路径设置值;$host请求信息中的&quot;Host&quot;，如果请求中没有Host行，则等于设置的服务器名;$limit_rate对连接速率的限制;$request_method请求的方法，比如&quot;GET&quot;、&quot;POST&quot;等;$remote_addr客户端地址;$remote_port客户端端口号;$remote_user客户端用户名，认证用;$request_filename   当前请求的文件路径名（带网站的主目录&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;images&#x2F;a.jpg）$request_uri当前请求的文件路径名（不带网站的主目录&#x2F;images&#x2F;a.jpg）$query_string与$args相同;$scheme用的协议，比如http或者是https$server_protocol请求的协议版本，&quot;HTTP&#x2F;1.0&quot;或&quot;HTTP&#x2F;1.1&quot;;$server_addr 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费);$server_name请求到达的服务器名;$document_uri 与$uri一样，URI地址;$server_port 请求到达的服务器端口号;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-2、Rewrite-flag"><a href="#2-2、Rewrite-flag" class="headerlink" title="2.2、Rewrite flag"></a>2.2、Rewrite flag</h6><p><strong>rewrite</strong>  指令根据表达式来重定向URI，或者修改字符串。可以应用于<strong>server,location, if</strong>环境下每行rewrite指令最后跟一个flag标记，支持的flag标记有：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">last     相当于Apache里的[L]标记，表示完成rewrite。默认为last。break 本条规则匹配完成后，终止匹配，不再匹配后面的规则redirect 返回302临时重定向，浏览器地址会显示跳转后的URL地址permanent     返回301永久重定向，浏览器地址会显示跳转后URL地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>redirect 和 permanent区别则是返回的不同方式的重定向，对于客户端来说一般状态下是没有区别的。而对于搜索引擎，相对来说301的重定向更加友好，如果我们把一个地址采用301跳转方式跳转的话，搜索引擎会把老地址的相关信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。使用302重定向时，搜索引擎(特别是google)有时会查看跳转前后哪个网址更直观，然后决定显示哪个，如果它觉的跳转前的URL更好的话，也许地址栏不会更改，那么很有可能出现URL劫持的现像。在做URI重写时，有时会发现URI中含有相关参数，如果需要将这些参数保存下来，并且在重写过程中重新引用，可以利用重定向 () 和 $N 的方式来解决。</p></li></ul><p>2.3、Rewrite匹配参考示例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">本地解析host文件# http:&#x2F;&#x2F;www.testpm.com&#x2F;a&#x2F;1.html &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.testpm.com&#x2F;b&#x2F;2.html    location &#x2F;a &#123;           root    &#x2F;html;              index   1.html index.htm;        rewrite .* &#x2F;b&#x2F;2.html permanent;        &#125;    location &#x2F;b &#123;        root    &#x2F;html;        index   2.html index.htm;        &#125;例2：# http:&#x2F;&#x2F;www.testpm.com&#x2F;2019&#x2F;a&#x2F;1.html &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.testpm.com&#x2F;2018&#x2F;a&#x2F;1.html     location &#x2F;2019&#x2F;a &#123;        root    &#x2F;var&#x2F;www&#x2F;html;        index   1.html index.hml;        rewrite ^&#x2F;2019&#x2F;(.*)$ &#x2F;2018&#x2F;$1 permanent;        &#125;     location &#x2F;2018&#x2F;a &#123;        root    &#x2F;var&#x2F;www&#x2F;html;        index   1.html index.htl;        &#125;例3：# http:&#x2F;&#x2F;www.qf.com&#x2F;a&#x2F;1.html &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;jd.comlocation &#x2F;a &#123;        root    &#x2F;html;        if ($host ~* www.qf.com ) &#123;        rewrite .* http:&#x2F;&#x2F;jd.com permanent;        &#125;        &#125;例4: 在访问目录后添加&#x2F;  (如果目录后已有&#x2F;，则不加&#x2F;)# http:&#x2F;&#x2F;www.tianyun.com&#x2F;a&#x2F;b&#x2F;c# $1: &#x2F;a&#x2F;b# $2: c# http:&#x2F;&#x2F;$host$1$2$3&#x2F;location &#x2F;a&#x2F;b&#x2F;c &#123;        root    &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index   index.html index.hml;        if (-d $request_filename) &#123;        rewrite ^(.*)([^&#x2F;])$ http:&#x2F;&#x2F;$host$1$2&#x2F; permanent;        &#125;        &#125;例5：# http:&#x2F;&#x2F;www.tianyun.com&#x2F;login&#x2F;tianyun.html &#x3D;&#x3D;&gt;  http:&#x2F;&#x2F;www.tianyun.com&#x2F;reg&#x2F;login.html?user&#x3D;tianyunlocation &#x2F;login &#123;        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        rewrite ^&#x2F;login&#x2F;(.*)\.html$ http:&#x2F;&#x2F;$host&#x2F;reg&#x2F;login.html?user&#x3D;$1;        &#125;    location &#x2F;reg &#123;        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index login.html;        &#125;例6：#http:&#x2F;&#x2F;www.tianyun.com&#x2F;qf&#x2F;11-22-33&#x2F;1.html  &#x3D;&#x3D;&gt;  http:&#x2F;&#x2F;www.tianyun.com&#x2F;qf&#x2F;11&#x2F;22&#x2F;33&#x2F;1.htmllocation &#x2F;qf &#123;            rewrite ^&#x2F;qf&#x2F;([0-9]+)-([0-9]+)-([0-9]+)(.*)$ &#x2F;qf&#x2F;$1&#x2F;$2&#x2F;$3$4 permanent;        &#125;        location &#x2F;qf&#x2F;11&#x2F;22&#x2F;33 &#123;                root &#x2F;html;                index   1.html;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-4、set-指令"><a href="#2-4、set-指令" class="headerlink" title="2.4、set 指令"></a>2.4、set 指令</h6><p>set 指令是用于定义一个变量，并且赋值</p><p>应用环境:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server,location,if<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应用示例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">例8：#http:&#x2F;&#x2F;alice.testpm.com &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.testpm.com&#x2F;alice#http:&#x2F;&#x2F;jack.testpm.com &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.testpm.com&#x2F;jack[root@nginx-server conf.d]# cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;[root@nginx-server html]# mkdir jack alice[root@nginx-server html]# echo &quot;jack..&quot; &gt;&gt; jack&#x2F;index.html[root@nginx-server html]# echo &quot;alice..&quot; &gt;&gt; alice&#x2F;index.htmla. DNS实现泛解析*   IN      A    网站IP或者本地解析域名host文件10.0.105.202 www.testpm.com10.0.105.202 alice.testpm.com10.0.105.202 jack.testpm.com编辑配置文件:server &#123;    listen       80;    server_name  www.testpm.com;    location &#x2F; &#123;         root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;         index  index.html index.htm;         if ( $host ~* ^www.testpm.com$) &#123;                break;                &#125;         if ( $host ~* &quot;^(.*)\.testpm\.com$&quot; ) &#123;                set $user $1;                rewrite .* http:&#x2F;&#x2F;www.testpm.com&#x2F;$user permanent;                &#125;        &#125;    location &#x2F;jack &#123;         root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;         index  index.html index.hml;        &#125;    location &#x2F;alice &#123;         root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;         index index.html index.hml;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-5、return-指令"><a href="#2-5、return-指令" class="headerlink" title="2.5、return 指令"></a>2.5、return 指令</h6><p>return 指令用于返回状态码给客户端</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server,location,if<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应用示例:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">例9：如果访问的.sh结尾的文件则返回403操作拒绝错误server &#123;    listen       80;    server_name  www.testpm.cn;    #access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;http_access.log  main;    location &#x2F; &#123;        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index  index.html index.htm;        &#125;    location ~* \.sh$ &#123;        return 403;        &#125;&#125;例10：80 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 443 ：80转443端口server &#123;    listen       80;    server_name  www.testpm.cn;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;http_access.log  main;    return 301 https:&#x2F;&#x2F;www.testpm.cn$request_uri;&#125;server &#123;    listen 443 ssl;    server_name www.testpm.cn;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;https_access.log  main;    #ssl on;   以下步骤为域名www.testpm.cn绑定ssl证书    ssl_certificate   &#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;2447549_www.testpm.cn.pem;    ssl_certificate_key  &#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;2447549_www.testpm.cn.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;    ssl_prefer_server_ciphers on;    location &#x2F; &#123;        root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        index index.html index.htm;    &#125;&#125;[root@nginx-server ~]# curl -I http:&#x2F;&#x2F;www.testpm.cnHTTP&#x2F;1.1 301 Moved PermanentlyServer: nginx&#x2F;1.16.0Date: Wed, 03 Jul 2019 13:52:30 GMTContent-Type: text&#x2F;htmlContent-Length: 169Connection: keep-aliveLocation: https:&#x2F;&#x2F;www.testpm.cn&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、last,break详解</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost test<span class="token punctuation">]</span><span class="token comment"># cat /etc/nginx/conf.d/last_break.conf </span>server <span class="token punctuation">&#123;</span>    listen       <span class="token number">80</span><span class="token punctuation">;</span>    server_name  localhost<span class="token punctuation">;</span>    access_log  /var/log/nginx/last.access.log  main<span class="token punctuation">;</span>    location / <span class="token punctuation">&#123;</span>        root   /usr/share/nginx/html<span class="token punctuation">;</span>        index  index.html index.htm<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    location /break/ <span class="token punctuation">&#123;</span>        root /usr/share/nginx/html<span class="token punctuation">;</span>        rewrite .* /test/break.html <span class="token builtin class-name">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    location /last/ <span class="token punctuation">&#123;</span>        root /usr/share/nginx/html<span class="token punctuation">;</span>        rewrite .* /test/last.html last<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    location /test/ <span class="token punctuation">&#123;</span>        root /usr/share/nginx/html<span class="token punctuation">;</span>        rewrite .* /test/test.html <span class="token builtin class-name">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span>root@localhost conf.d<span class="token punctuation">]</span><span class="token comment"># cd /usr/share/nginx/html/</span><span class="token punctuation">[</span>root@localhost html<span class="token punctuation">]</span><span class="token comment"># mkdir test</span><span class="token punctuation">[</span>root@localhost html<span class="token punctuation">]</span><span class="token comment"># echo "last" > test/last.html</span><span class="token punctuation">[</span>root@localhost html<span class="token punctuation">]</span><span class="token comment"># echo "break" > test/break.html</span><span class="token punctuation">[</span>root@localhost html<span class="token punctuation">]</span><span class="token comment"># echo "test" > test/test.html</span>http://10.0.105.196/break/break.htmlhttp://10.0.105.196/last/last.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><ul><li><p>last 标记在本条 rewrite 规则执行完后，会对其所在的 server { … } 标签重新发起请求; </p></li><li><p>break 标记则在本条规则匹配完成后，停止匹配，不再做后续的匹配；</p></li><li><p>使用 proxy_pass 指令时,则必须使用break。</p><p><strong>4、Nginx 的 https  ( rewrite )</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">server  <span class="token punctuation">&#123;</span>     listen       <span class="token number">80</span><span class="token punctuation">;</span>    server_name  <span class="token operator">*</span><span class="token punctuation">.</span>vip9999<span class="token punctuation">.</span>top vip9999<span class="token punctuation">.</span>top<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>$host <span class="token operator">~</span><span class="token operator">*</span> <span class="token string">"^www.vip9999.top$|^vip9999.top$"</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">301</span> https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>vip9999<span class="token punctuation">.</span>top$request_uri<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>$host <span class="token operator">~</span><span class="token operator">*</span> <span class="token string">"^(.*).vip9999.top$"</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token builtin">set</span> $user $<span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">301</span> https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>vip9999<span class="token punctuation">.</span>top<span class="token operator">/</span>$user<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment"># Settings for a TLS enabled server.</span>server <span class="token punctuation">&#123;</span>    listen       <span class="token number">443</span> ssl<span class="token punctuation">;</span>    server_name  www<span class="token punctuation">.</span>vip9999<span class="token punctuation">.</span>top<span class="token punctuation">;</span>      location <span class="token operator">/</span> <span class="token punctuation">&#123;</span>            root      <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>nginx<span class="token operator">/</span>html<span class="token punctuation">;</span>            index     index<span class="token punctuation">.</span>php index<span class="token punctuation">.</span>html<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>      <span class="token comment">#pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>    location <span class="token operator">~</span> \<span class="token punctuation">.</span>php$ <span class="token punctuation">&#123;</span>        root           <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>nginx<span class="token operator">/</span>html<span class="token punctuation">;</span>        fastcgi_pass   <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">9000</span><span class="token punctuation">;</span>        fastcgi_index  index<span class="token punctuation">.</span>php<span class="token punctuation">;</span>        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name<span class="token punctuation">;</span>        include        fastcgi_params<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ssl on<span class="token punctuation">;</span>    ssl_certificate cert<span class="token operator">/</span><span class="token number">214025315060640.</span>pem<span class="token punctuation">;</span>    ssl_certificate_key cert<span class="token operator">/</span><span class="token number">214025315060640.</span>key<span class="token punctuation">;</span>    ssl_session_cache shared<span class="token punctuation">:</span>SSL<span class="token punctuation">:</span>1m<span class="token punctuation">;</span>    ssl_session_timeout  10m<span class="token punctuation">;</span>    ssl_ciphers HIGH<span class="token punctuation">:</span>!aNULL<span class="token punctuation">:</span>!MD5<span class="token punctuation">;</span>    ssl_prefer_server_ciphers on<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="nginx-try-files-用法s"><a href="#nginx-try-files-用法s" class="headerlink" title="nginx try_files 用法s"></a>nginx try_files 用法s</h4><table><thead><tr><th align="left">Syntax:</th><th>try_files   file … uri;   try_files    file … =code;</th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td>server,    location</td></tr></tbody></table><p>按指定顺序检查文件是否存在，并使用第一个找到的文件进行请求处理；处理是在当前上下文中执行的。文件的路径是<code>file</code>根据<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#root">root</a>和<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#alias">alias</a>指令从参数 构造的 。可以通过在名称末尾指定斜杠来检查目录是否存在，例如 <code>$uri/</code>。如果没有找到任何文件，<code>uri</code>则进行到最后一个参数中指定的内部重定向 。例如：</p><blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location /images/ <span class="token punctuation">&#123;</span>     try_files <span class="token variable">$uri</span> /images/default.gif<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> location <span class="token operator">=</span> /images/default.gif <span class="token punctuation">&#123;</span>    expires 30s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>最后一个参数也可以指向一个命名位置，如下面的示例所示。从 0.7.51 版本开始，最后一个参数也可以是一个 <code>code</code>：</p><blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location / <span class="token punctuation">&#123;</span>     try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/index.html  <span class="token variable">$uri</span>.html <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>更多try_files用法参考：<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#try_files">https://nginx.org/en/docs/http/ngx_http_core_module.html#try_files</a></p></li></ul><h3 id="2、nginx的localtion指令详解"><a href="#2、nginx的localtion指令详解" class="headerlink" title="2、nginx的localtion指令详解"></a>2、nginx的localtion指令详解</h3><p>Nginx 的 HTTP 配置主要包括三个区块，结构如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">http <span class="token punctuation">&#123;</span> <span class="token comment"># 这个是协议级别</span>　　include mime.types<span class="token punctuation">;</span>　　default_type application/octet-stream<span class="token punctuation">;</span>　　keepalive_timeout <span class="token number">65</span><span class="token punctuation">;</span>　　<span class="token function">gzip</span> on<span class="token punctuation">;</span>　　　　server <span class="token punctuation">&#123;</span> <span class="token comment"># 这个是服务器级别</span>　　　　　　listen <span class="token number">80</span><span class="token punctuation">;</span>　　　　　　server_name localhost<span class="token punctuation">;</span>　　　　　　　　location / <span class="token punctuation">&#123;</span>  <span class="token comment"># 这个是请求级别</span>　　　　　　　　　　root html<span class="token punctuation">;</span>　　　　　　　　　　index index.html index.htm<span class="token punctuation">;</span>　　　　　　　　<span class="token punctuation">&#125;</span>　　　　　　<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1、location-区段"><a href="#1、location-区段" class="headerlink" title="1、location 区段"></a>1、location 区段</h5><ul><li><p>location 是在 server 块中配置，根据不同的 URI 使用不同的配置，来处理不同的请求。</p></li><li><p>location 是有顺序的，会被第一个匹配的location 处理。</p></li><li><p>基本语法如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location <span class="token punctuation">[</span><span class="token operator">=</span><span class="token operator">|</span>~<span class="token operator">|</span>~*<span class="token operator">|</span>^~<span class="token operator">|</span>@<span class="token punctuation">]</span> pattern<span class="token punctuation">&#123;</span>……<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="2、location-前缀含义"><a href="#2、location-前缀含义" class="headerlink" title="2、location 前缀含义"></a>2、<strong>location 前缀含义</strong></h5>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token operator">=</span>    表示精确匹配，优先级也是最高的 ^~   表示uri以某个常规字符串开头,理解为匹配url路径即可 ~    表示区分大小写的正则匹配  ~*   表示不区分大小写的正则匹配<span class="token operator">!</span>~   表示区分大小写不匹配的正则<span class="token operator">!</span>~*  表示不区分大小写不匹配的正则/    通用匹配，任何请求都会匹配到@    内部服务跳转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3、location-配置示例"><a href="#3、location-配置示例" class="headerlink" title="3、location 配置示例"></a>3、location 配置示例</h5><p>  本地解析域名host</p><p>  1、没有修饰符 表示：必须以指定模式开始</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server <span class="token punctuation">&#123;</span>    listen       <span class="token number">80</span><span class="token punctuation">;</span>    server_name  qf.com<span class="token punctuation">;</span>    location  /abc <span class="token punctuation">&#123;</span>        root    /home/www/nginx<span class="token punctuation">;</span>        index   <span class="token number">2</span>.html<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>那么，如下是对的：http://qf.com/abchttp://qf.com/abc?p1http://qf.com/abc/http://qf.com/abcde <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2、=表示：必须与指定的模式精确匹配</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server <span class="token punctuation">&#123;</span>    listen       <span class="token number">80</span><span class="token punctuation">;</span>    server_name  www.testpm.cn<span class="token punctuation">;</span>    access_log  /var/log/nginx/http_access.log  main<span class="token punctuation">;</span>    location / <span class="token punctuation">&#123;</span>        root /usr/share/nginx/html<span class="token punctuation">;</span>        index index.html index.htm<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    location <span class="token operator">=</span> /abc <span class="token punctuation">&#123;</span>        root /usr/share/nginx/html<span class="token punctuation">;</span>        index index.html index.htm<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>那么，如下是对的：http://qf.com/abchttp://qf.com/abc?p1http://qf.com/abc/如下是错的http://qf.com/abcde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  3、~ 表示：指定的正则表达式要区分大小写</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server <span class="token punctuation">&#123;</span>server_name qf.com<span class="token punctuation">;</span>　　location ~ ^/abc$ <span class="token punctuation">&#123;</span>　　　　……　　<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>那么，如下是对的：http://qf.com/abchttp://qf.com/abc?p1<span class="token operator">=</span><span class="token number">11</span><span class="token operator">&amp;</span><span class="token assign-left variable">p2</span><span class="token operator">=</span><span class="token number">22</span>如下是错的http://qf.com/ABChttp://qf.com/abc/http://qf.com/abcde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  4、~* 表示：指定的正则表达式不区分大小写</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server <span class="token punctuation">&#123;</span>server_name qf.com<span class="token punctuation">;</span>location ~* ^/abc$ <span class="token punctuation">&#123;</span>　　　　……　　<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>那么，如下是对的：http://qf.com/abchttp://qf.com/ABChttp://qf.com/abc?p1<span class="token operator">=</span><span class="token number">11</span><span class="token operator">&amp;</span><span class="token assign-left variable">p2</span><span class="token operator">=</span><span class="token number">22</span>如下是错的：http://qf.com/abc/http://qf.com/abcde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  5、^~ ：类似于无修饰符的行为，也是以指定模式开始，不同的是，如果模式匹配，那么就停止搜索其他模式了。<br>  6、@ ：定义命名 location 区段，这些区段客户段不能访问，只可以由内部产生的请求来访问，如try_files或error_page等</p><p>  <strong>查找顺序和优先级</strong></p><p>  <strong>1：带有 = 的精确匹配优先</strong></p><p>  <strong>2：没有修饰符的精确匹配</strong></p><p>  <strong>3：正则表达式按照他们在配置文件中定义的顺序</strong></p><p>  <strong>4：带有 ^~ 修饰符的，开头匹配</strong></p><p>  <em><em>5：带有 ~  或 ~</em>  修饰符的，如果正则表达式与URI匹配</em>*</p><p>  <strong>6：没有修饰符的，如果指定字符串与URI开头匹配</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token operator">=</span> 大于 ^~  大于 ~<span class="token operator">|</span>~*<span class="token operator">|</span><span class="token operator">!</span>~<span class="token operator">|</span><span class="token operator">!</span>~* 大于 /多个location配置的情况下匹配顺序为：首先匹配 <span class="token operator">=</span>，其次匹配^~, 其次是按正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span>:表示完全匹配<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> ^~:匹配URI的前缀，并且后面的正则表达式不再匹配，如果一个URI同时满足两个规则的话，匹配最长的规则<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> ~:匹配正则表达式，大小写敏感；<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> ~*:匹配正则表达式，大小写不敏感；优先级：（1）<span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location 区段匹配示例location <span class="token operator">=</span> / <span class="token punctuation">&#123;</span>　　<span class="token comment"># 只匹配 / 的查询.</span>　　<span class="token punctuation">[</span> configuration A <span class="token punctuation">]</span><span class="token punctuation">&#125;</span>location / <span class="token punctuation">&#123;</span>　　<span class="token comment"># 匹配任何以 / 开始的查询，但是正则表达式与一些较长的字符串将被首先匹配。</span>　　<span class="token punctuation">[</span> configuration B <span class="token punctuation">]</span><span class="token punctuation">&#125;</span>location ^~ /images/ <span class="token punctuation">&#123;</span>　　<span class="token comment"># 匹配任何以 /images/ 开始的查询并且停止搜索，不检查正则表达式。</span>　　<span class="token punctuation">[</span> configuration C <span class="token punctuation">]</span><span class="token punctuation">&#125;</span>location ~* <span class="token punctuation">\</span>.<span class="token punctuation">(</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>jpeg<span class="token punctuation">)</span>$ <span class="token punctuation">&#123;</span>　　<span class="token comment"># 匹配任何以gif, jpg, or jpeg结尾的文件，但是所有 /images/ 目录的请求将在Configuration C中处理。</span>　　<span class="token punctuation">[</span> configuration D <span class="token punctuation">]</span><span class="token punctuation">&#125;</span> 各请求的处理如下例：/ → configuration A/documents/document.html → configuration B/images/1.gif → configuration C/documents/1.jpg → configuration D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、root 、alias 指令区别</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">location /img/ <span class="token punctuation">&#123;</span>    <span class="token builtin class-name">alias</span> /var/www/image/<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件</span>location /img/ <span class="token punctuation">&#123;</span>    root /var/www/image<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件。]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>alias 是一个目录别名的定义，</li><li>root 则是最上层目录的定义。</li><li>还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的,而root则可有可无</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> rewrite </tag>
            
            <tag> location </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx反向代理与负载均衡</title>
      <link href="/2021/08/14/nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2021/08/14/nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1、nginx-Proxy-代理"><a href="#1、nginx-Proxy-代理" class="headerlink" title="1、nginx Proxy 代理"></a>1、nginx Proxy 代理</h3><p><strong>1、nginx Proxy 配置</strong></p><p>1、代理模块</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ngx_http_proxy_module<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、代理配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">代理Syntax: proxy_pass URL;   #代理的后端服务器URLDefault: —Context: location, if in location, limit_except缓冲区Syntax:     proxy_buffering on | off;Default:    proxy_buffering on;   #缓冲开关Context: http, server, locationproxy_buffering开启的情况下，nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端（边收边传，不是全部接收完再传给客户端)。Nginx 全局配置中的 tcp_nopush 的作用就是 数据包会累计到一定大小之后才会发送 。而 tcp_nodelay 是尽快发送数据，所以若你启用了 buffer，建议关闭 tcp_nodelay。Syntax:   proxy_buffer_size size;Default: proxy_buffer_size 4k|8k;   #缓冲区大小Context: http, server, locationSyntax: proxy_buffers number size;Default: proxy_buffers 8 4k|8k;   #缓冲区数量Context: http, server, locationSyntax:    proxy_busy_buffers_size size;Default: proxy_busy_buffers_size 8k|16k;#忙碌的缓冲区大小控制同时传递给客户端的buffer数量Context: http, server, location头信息Syntax: proxy_set_header field value;Default: proxy_set_header Host $proxy_host;#设置真实客户端地址            proxy_set_header Connection close;Context: http, server, location超时Syntax: proxy_connect_timeout time;Default: proxy_connect_timeout 60s;#链接超时Context: http, server, locationSyntax: proxy_read_timeout time;Default: proxy_read_timeout 60s;Context: http, server, locationSyntax: proxy_send_timeout time; #nginx进程向fastcgi进程发送request的整个过程的超时时间Default: proxy_send_timeout 60s;Context: http, server, location#buffer 工作原理1. 所有的proxy buffer参数是作用到每一个请求的。每一个请求会安按照参数的配置获得自己的buffer。proxy buffer不是global而是 request的。2. proxy_buffering 是为了开启response buffering of the proxied server，开启后proxy_buffers和proxy_busy_buffers_size参数才会起作用。3. 无论proxy_buffering是否开启，proxy_buffer_size（main buffer）都是工作的，proxy_buffer_size所设置的buffer_size的作用是用来存储upstream端response的header。4. 在proxy_buffering 开启的情况下，Nginx将会尽可能的读取所有的upstream端传输的数据到buffer，直到proxy_buffers设置的所有buffer们 被写满或者数据被读取完(EOF)。此时nginx开始向客户端传输数据，会同时传输这一整串buffer们。同时如果response的内容很大的话，Nginx会接收并把他们写入到temp_file里去。大小由proxy_max_temp_file_size控制。如果busy的buffer 传输完了会从temp_file里面接着读数据，直到传输完毕。5. 一旦proxy_buffers设置的buffer被写入，直到buffer里面的数据被完整的传输完（传输到客户端），这个buffer将会一直处 在busy状态，我们不能对这个buffer进行任何别的操作。所有处在busy状态的buffer size加起来不能超过proxy_busy_buffers_size，所以proxy_busy_buffers_size是用来控制同时传输到客户端的buffer数量的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、启用 nginx proxy 代理</strong></p><p>环境两台nginx真实服务器</p><p>a、nginx-1 启动网站(内容)（作为网站服务器）</p><p>b、nginx-2 启动代理程序</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx-2的ip:10.0.105.202配置nginx的yum源直接yum安装启动编辑nginx的配置文件:[root@nginx-server ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.confserver &#123;    server &#123;    listen       80;    server_name  localhost;    location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;10.0.105.199:80;    proxy_redirect default;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    #proxy_set_header REMOTE-HOST $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_connect_timeout 30;    proxy_send_timeout 60;    proxy_read_timeout 60;    proxy_buffering on;    proxy_buffer_size 32k;    proxy_buffers 4 128k;    proxy_busy_buffers_size 256k;    proxy_max_temp_file_size 256k;    &#125;&#125;重新加载nginx配置文件[root@nginx-server ~]# nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>c、nginx proxy 具体配置详解</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">proxy_pass ：真实服务器的地址，可以是ip也可以是域名和url地址proxy_redirect ：如果真实服务器使用的是的真实IP:非默认端口。则改成IP：默认端口。proxy_set_header：重新定义或者添加发往后端服务器的请求头proxy_set_header X-Real-IP ：启用客户端真实地址（否则日志中显示的是代理在访问网站）proxy_set_header X-Forwarded-For：记录代理地址proxy_connect_timeout：:后端服务器连接的超时时间发起三次握手等候响应超时时间proxy_send_timeout：后端服务器数据回传时间就是在规定时间之内后端服务器必须传完所有的数据proxy_read_timeout ：nginx接收upstream（上游&#x2F;真实） server数据超时, 默认60s, 如果连续的60s内没有收到1个字节, 连接关闭。像长连接proxy_buffering on;开启缓存proxy_buffer_size：proxy_buffer_size只是响应头的缓冲区proxy_buffers 4 128k; 内容缓冲区域大小proxy_busy_buffers_size 256k; 从proxy_buffers划出一部分缓冲区来专门向客户端传送数据的地方proxy_max_temp_file_size 256k;超大的响应头存储成文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">proxy_set_header X-Real-IP 未配置Nginxbackend 的日志：记录只有192.168.107.112配置Nginxbackend 的日志,记录的有192.168.107.16 192.168.107.107 192.168.107.112proxy_buffers 的缓冲区大小一般会设置的比较大，以应付大网页。 proxy_buffers当中单个缓冲区的大小是由系统的内存页面大小决定的，Linux系统中一般为4k。 proxy_buffers由缓冲区数量和缓冲区大小组成的。总的大小为number*size。若某些请求的响应过大,则超过_buffers的部分将被缓冲到硬盘(缓冲目录由_temp_path指令指定), 当然这将会使读取响应的速度减慢, 影响用户体验. 可以使用proxy_max_temp_file_size指令关闭磁盘缓冲.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多详细代理设置参考官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header</a></p><p>观察nginx-1服务器的日志 (记得打开下面的日志路径,默认为/var/log)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">10.0.105.202 - - [27&#x2F;Jun&#x2F;2019:15:54:17 +0800] &quot;GET &#x2F; HTTP&#x2F;1.0&quot; 304 0 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.100 Safari&#x2F;537.36&quot; &quot;10.0.105.207&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>10.0.105.202  代理服务器地址</p><p>10.0.105.207 客户机地址。</p><p>访问成功。 记录了客户机的IP和代理服务器的IP</p><h3 id="2、Nginx负载均衡"><a href="#2、Nginx负载均衡" class="headerlink" title="2、Nginx负载均衡"></a>2、Nginx负载均衡</h3><p><a href="https://zhuanlan.zhihu.com/p/64777456">https://zhuanlan.zhihu.com/p/64777456</a>  知乎对7层负载的介绍</p><h6 id="1、负载均衡的作用"><a href="#1、负载均衡的作用" class="headerlink" title="1、负载均衡的作用"></a>1、负载均衡的作用</h6><p>如果你的nginx服务器给2台web服务器做代理，负载均衡算法采用轮询，那么当你的一台机器web程序关闭造成web不能访问，那么nginx服务器分发请求还是会给这台不能访问的web服务器，如果这里的响应连接时间过长，就会导致客户端的页面一直在等待响应，对用户来说体验就打打折扣，这里我们怎么避免这样的情况发生呢。</p><p>如果负载均衡中其中web2发生这样的情况，nginx首先会去web1请求，但是nginx在配置不当的情况下会继续分发请求道web2，然后等待web2响应，直到我们的响应时间超时，才会把请求重新分发给web1，这里的响应时间如果过长，用户等待的时间就会越长。</p><p>下面的配置是解决方案之一。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">proxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否中断对被代理服务器的请求。默认为off。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用upstream指令配置一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一组服务器处理.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">proxy_next_upstream timeout;  #反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误。</p><p>timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时。</p><p>invalid_header:被代理服务器返回的响应头异常。</p><p>off:无法将请求分发给被代理的服务器。</p><p>http_400，….:被代理服务器返回的状态码为400，500，502，等</p><p>2、upstream配置</p><p>首先给大家说下 upstream 这个配置的，这个配置是写一组被代理的服务器地址，然后配置负载均衡的算法。这里的被代理服务器地址有2中写法。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream testapp &#123;       server 10.0.105.199:8081;      server 10.0.105.202:8081;    &#125; server &#123;        ....        location &#x2F; &#123;                    proxy_pass  http:&#x2F;&#x2F;testapp;  #请求转向 testapp 定义的服务器列表                 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream mysvr &#123;       server  http:&#x2F;&#x2F;10.0.105.199:8081;      server  http:&#x2F;&#x2F;10.0.105.202:8081;    &#125; server &#123;        ....        location  &#x2F; &#123;                    proxy_pass  http:&#x2F;&#x2F;mysvr;  #请求转向mysvr 定义的服务器列表                 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="1、负载均衡算法"><a href="#1、负载均衡算法" class="headerlink" title="1、负载均衡算法"></a>1、负载均衡算法</h6><p>upstream 支持4种负载均衡调度算法:</p><p>A、<code>轮询(默认)</code>:每个请求按时间顺序逐一分配到不同的后端服务器;</p><p>B、<code>ip_hash</code>:每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</p><p>C、<code>url_hash</code>:按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器。后台服务器为缓存的时候提高效率。</p><p>D、<code>fair</code>:这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。<code>Nginx</code>本身是不支持 <code>fair</code>的，如果需要使用这种调度算法，必须下载Nginx的 <code>upstream_fair</code>模块。</p><p><strong>2、配置实例</strong></p><p>1、热备：如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB…..</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;       server 172.17.14.3:8080 backup;  #热备         &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、轮询：nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB….</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;      server 172.17.14.3:8080;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3、加权轮询：跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB….</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080 weight&#x3D;1;      server 172.17.14.3:8080 weight&#x3D;2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4、ip_hash:nginx会让相同的客户端ip请求相同的服务器。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;       server 172.17.14.3:8080;      ip_hash;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、nginx负载均衡配置状态参数</p><ul><li>down，表示当前的server暂时不参与负载均衡。</li><li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li><li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li><li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间单位秒。max_fails可以和fail_timeout一起使用。</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream myweb &#123;      server 172.17.14.2:8080 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2;     server 172.17.14.3:8080 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;1;       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你像跟多更深入的了解 nginx 的负载均衡算法，nginx官方提供一些插件大家可以了解下。 </p><p>Nginx官方文档：<a href="http://nginx.org/en/docs/http/load_balancing.html">http://nginx.org/en/docs/http/load_balancing.html</a></p><h6 id="3、nginx配置7层协议及4层协议方法（扩展）"><a href="#3、nginx配置7层协议及4层协议方法（扩展）" class="headerlink" title="3、nginx配置7层协议及4层协议方法（扩展）"></a>3、nginx配置7层协议及4层协议方法（扩展）</h6><p>准备三台机器:</p><p>代理服务器配置本地host解析域名；</p><p>后端服务器两台，需安装nginx并将nginx服务启动</p><h6 id="——配置代理服务器的nginx配置文件-相对完整的配置-——"><a href="#——配置代理服务器的nginx配置文件-相对完整的配置-——" class="headerlink" title="——配置代理服务器的nginx配置文件(相对完整的配置)——"></a>——配置代理服务器的nginx配置文件(相对完整的配置)——</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">worker_processes  4;worker_rlimit_nofile 102400;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application&#x2F;octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs&#x2F;access.log  main;    sendfile        on;    keepalive_timeout  65;    gzip  on;    upstream testweb &#123;   代理服务器分组ip_hash;      server 10.0.105.199:80 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2s;   server 10.0.105.202:80 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2s;        &#125;    server &#123;        listen       80;        server_name  www.test.com;        charset utf-8;        #access_log  logs&#x2F;host.access.log  main;        location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;testweb;                proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        &#125;        error_page   500 502 503 504  &#x2F;50x.html;        location &#x3D; &#x2F;50x.html &#123;            root   html;        &#125;&#125;     upstream testapp &#123; server 10.0.105.202:8081 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2s;      server 10.0.105.199:8081 weight&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;2s;               &#125;     server &#123;listen    81;server_namewww.app.com;charset utf-8;#access_log  logs&#x2F;host.access.log  main;location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;testapp;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>浏览器测试访问:</p><p><a href="http://www.test.com/">http://www.test.com/</a></p><p><a href="http://www.app.com:81/">http://www.app.com:81/</a></p><p>202服务器yum安装的创建新的配置文件:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-server ~]# cd &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;[root@nginx-server conf.d]# cp default.conf test.conf[root@nginx-server conf.d]# cat test.conf server &#123;    listen       80;    server_name  localhost;    location &#x2F; &#123;         root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;         index  index.html index.htm;    &#125;&#125;server &#123;    listen       8081;    server_name  localhost;    location &#x2F; &#123;         root   &#x2F;var&#x2F;www&#x2F;nginx&#x2F;html;         index  index.html index.htm;    &#125;&#125;[root@nginx-server ~]# nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nginx在1.9.0的时候，增加了一个 stream 模块，用来实现四层协议（网络层和传输层）的转发、代理、负载均衡等。stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#4层tcp负载 stream &#123;upstream myweb &#123;                hash $remote_addr consistent;                server 172.17.14.2:8080;                server 172.17.14.3:8080;        &#125;        server &#123;            listen 82;            proxy_connect_timeout 10s;            proxy_timeout 30s;            proxy_pass myweb;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>nginx 会话保持</strong></p><p>nginx会话保持主要有以下几种实现方式。</p><h5 id="1、ip-hash"><a href="#1、ip-hash" class="headerlink" title="1、ip_hash"></a><strong>1、ip_hash</strong></h5><p>ip_hash使用源地址哈希算法，将同一客户端的请求总是发往同一个后端服务器，除非该服务器不可用。</p><p>ip_hash语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream backend &#123;    ip_hash;    server backend1.example.com;    server backend2.example.com;    server backend3.example.com down;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ip_hash简单易用，但有如下问题：<br>当后端服务器宕机后，session会丢失；<br>来自同一局域网的客户端会被转发到同一个后端服务器，可能导致负载失衡；<br>不适用于CDN网络，不适用于前段还有代理的情况。</p><h5 id="2、sticky-cookie-insert"><a href="#2、sticky-cookie-insert" class="headerlink" title="2、sticky_cookie_insert"></a>2、sticky_cookie_insert</h5><p>使用sticky_cookie_insert启用会话亲缘关系，这会导致来自同一客户端的请求被传递到一组服务器的同一台服务器。与ip_hash不同之处在于，它不是基于IP来判断客户端的，而是基于cookie来判断。因此可以避免上述ip_hash中来自同一局域网的客户端和前段代理导致负载失衡的情况。(需要引入第三方模块才能实现)<br>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">upstream backend &#123;    server backend1.example.com;    server backend2.example.com;    sticky_cookie_insert srv_id expires&#x3D;1h domain&#x3D;3evip.cn path&#x3D;&#x2F;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<br>expires：设置浏览器中保持cookie的时间<br>domain：定义cookie的域<br>path：为cookie定义路径</p><h5 id="3、jvm-route方式"><a href="#3、jvm-route方式" class="headerlink" title="3、jvm_route方式"></a><strong>3、jvm_route方式</strong></h5><p>　　jvm_route是通过session_cookie这种方式来实现session粘性。将特定会话附属到特定tomcat上，从而解决session不同步问题，但是无法解决宕机后会话转移问题。如果在cookie和url中并没有session，则这只是个简单的round-robin负载均衡。</p><p>　　jvm_route的原理</p><ul><li>一开始请求过来，没有带session的信息，jvm_route就根据round robin的方法，发到一台Tomcat上面</li><li>Tomcat添加上session信息，并返回给客户</li><li>用户再次请求，jvm_route看到session中有后端服务器的名称，他就把请求转到对应的服务器上</li></ul><p>　　暂时jvm_route模块还不支持fair的模式。jvm_route的工作模式和fair是冲突的。对于某个特定用户，当一直为他服务的Tomcat宕机后，默认情况下它会重试max_fails的次数，如果还是失败，就重新启用round robin的方式，而这种情况下就会导致用户的session丢失。</p><p><strong>4、使用后端服务器自身通过相关机制保持session同步，如：使用数据库、redis、memcached 等做session复制</strong></p><h3 id="nginx-实现动静分离"><a href="#nginx-实现动静分离" class="headerlink" title="nginx 实现动静分离"></a>nginx 实现动静分离</h3><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 在动静分离的tomcat的时候比较明显，因为tomcat解析静态很慢，其实这些原理的话都很好理解，简单来说，就是使用正则表达式匹配过滤，然后交个不同的服务器。</p><p><strong>1、准备环境</strong></p><p>准备一个nginx代理 两个http 分别处理动态和静态。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1.配置nginx反向代理upstream；upstream static &#123;        server 10.0.105.196:80 weight&#x3D;1 max_fails&#x3D;1 fail_timeout&#x3D;60s;        &#125;upstream php &#123;        server 10.0.105.200:80 weight&#x3D;1 max_fails&#x3D;1 fail_timeout&#x3D;60s;        &#125;     server &#123;        listen      80;        server_name     localhost;        #动态资源加载        location ~ \.(php|jsp)$ &#123;            proxy_pass http:&#x2F;&#x2F;php;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                &#125;        #静态资源加载        location ~ .*\.(html|gif|jpg|png|bmp|swf|css|js)$ &#123;            proxy_pass http:&#x2F;&#x2F;static;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                &#125;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">静态资源配置server &#123;        listen 80;        server_name     localhost;        location ~ \.(html|jpg|png|js|css|gif|bmp|jpeg) &#123;        root &#x2F;home&#x2F;www&#x2F;nginx;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">动态资源配置:yum 安装php7.1[root@nginx-server ~]#rpm -Uvh https:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el7&#x2F;epel-release.rpm[root@nginx-server ~]#rpm -Uvh https:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el7&#x2F;webtatic-release.rpm[root@nginx-server ~]#yum install php71w-xsl php71w php71w-ldap php71w-cli php71w-common php71w-devel php71w-gd php71w-pdo php71w-mysql php71w-mbstring php71w-bcmath php71w-mcrypt -y[root@nginx-server ~]#yum install -y php71w-fpm[root@nginx-server ~]#systemctl start php-fpm[root@nginx-server ~]#systemctl enable php-fpm编辑nginx的配置文件:server &#123;        listen      80;        server_name     localhost;        location ~ \.php$ &#123;            root           &#x2F;home&#x2F;nginx&#x2F;html;  #指定网站目录            fastcgi_pass   127.0.0.1:9000;    #指定访问地址            fastcgi_index  index.php;#指定默认文件            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name; #站点根目录，取决于root配置项            include        fastcgi_params;  #包含nginx常量定义        &#125;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当访问静态页面的时候location 匹配到 (html|jpg|png|js|css|gif|bmp|jpeg) 通过转发到静态服务器，静态服务通过location的正则匹配来处理请求。</p><p>当访问动态页面时location匹配到 .php 结尾的文件转发到后端php服务处理请求。</p><h3 id><a href="#" class="headerlink" title></a></h3><h6 id="-1"><a href="#-1" class="headerlink" title></a></h6>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 反向代理 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx编译安装</title>
      <link href="/2021/08/13/nginx/nginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
      <url>/2021/08/13/nginx/nginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="1、nginx-编译安装与配置使用"><a href="#1、nginx-编译安装与配置使用" class="headerlink" title="1、nginx 编译安装与配置使用"></a>1、nginx 编译安装与配置使用</h3><h5 id="1、安装编译环境"><a href="#1、安装编译环境" class="headerlink" title="1、安装编译环境"></a>1、安装编译环境</h5><p><code>yum -y install gcc gcc-c++</code></p><h5 id="2、安装pcre软件包（使nginx支持http-rewrite模块）"><a href="#2、安装pcre软件包（使nginx支持http-rewrite模块）" class="headerlink" title="2、安装pcre软件包（使nginx支持http rewrite模块）"></a>2、安装pcre软件包（使nginx支持http rewrite模块）</h5><p><code>yum install -y pcre pcre-devel</code></p><h5 id="3、安装openssl-devel（使nginx支持ssl）"><a href="#3、安装openssl-devel（使nginx支持ssl）" class="headerlink" title="3、安装openssl-devel（使nginx支持ssl）"></a>3、安装openssl-devel（使nginx支持ssl）</h5><p><code>yum install -y openssl openssl-devel </code></p><h5 id="4、安装zlib"><a href="#4、安装zlib" class="headerlink" title="4、安装zlib"></a>4、安装zlib</h5><p><code>yum install -y zlib zlib-devel</code></p><h5 id="5、创建用户nginx"><a href="#5、创建用户nginx" class="headerlink" title="5、创建用户nginx"></a>5、创建用户nginx</h5><p><code>useradd nginx </code></p><p><code>passwd nginx</code>  （系统用户不给予密码更安全）</p><p><strong>6、安装nginx</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># wget http://nginx.org/download/nginx-1.16.0.tar.gz</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># tar xzf nginx-1.16.0.tar.gz -C /usr/local/</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cd nginx-1.16.0</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># wget https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz  </span>    <span class="token comment"># 此处为下载一个echo-nginx-module模块，可实现在nginx配置文件中使用echo打印，辅助排错，可不装</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># tar xf v0.61.tar.gz</span><span class="token punctuation">[</span>root@localhost nginx-1.16.0<span class="token punctuation">]</span><span class="token comment"># ./configure --prefix=/usr/local/nginx --group=nginx --user=nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/tmp/nginx/client_body --http-proxy-temp-path=/tmp/nginx/proxy --http-fastcgi-temp-path=/tmp/nginx/fastcgi --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream</span><span class="token punctuation">[</span>root@localhost nginx-1.16.0<span class="token punctuation">]</span><span class="token comment"># make &amp;&amp; make install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>7、Nginx 编译参数</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看 nginx 安装的模块</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment">#/usr/local/nginx/sbin/nginx -V</span><span class="token comment"># 模块参数具体功能 </span>--with-cc-opt<span class="token operator">=</span><span class="token string">'-g -O2 -fPIE -fstack-protector    //设置额外的参数将被添加到CFLAGS变量。（FreeBSD或者ubuntu使用）--param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2'</span> --with-ld-opt<span class="token operator">=</span><span class="token string">'-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now'</span> --prefix<span class="token operator">=</span>/usr/local/nginx                        //指向安装目录--conf-path<span class="token operator">=</span>/etc/nginx/nginx.conf                //指定配置文件--http-log-path<span class="token operator">=</span>/var/log/nginx/access.log        //指定访问日志--error-log-path<span class="token operator">=</span>/var/log/nginx/error.log        //指定错误日志--lock-path<span class="token operator">=</span>/var/lock/nginx.lock                 //指定lock文件--pid-path<span class="token operator">=</span>/run/nginx.pid                        //指定pid文件--http-client-body-temp-path<span class="token operator">=</span>/var/lib/nginx/body    //设定http客户端请求临时文件路径--http-fastcgi-temp-path<span class="token operator">=</span>/var/lib/nginx/fastcgi     //设定http fastcgi临时文件路径--http-proxy-temp-path<span class="token operator">=</span>/var/lib/nginx/proxy         //设定http代理临时文件路径--http-scgi-temp-path<span class="token operator">=</span>/var/lib/nginx/scgi           //设定http scgi临时文件路径--http-uwsgi-temp-path<span class="token operator">=</span>/var/lib/nginx/uwsgi         //设定http uwsgi临时文件路径--with-debug                                        //启用debug日志--with-pcre-jit                                     //编译PCRE包含“just-in-time compilation”--with-ipv6                                         //启用ipv6支持--with-http_ssl_module                              //启用ssl支持--with-http_stub_status_module                      //获取nginx自上次启动以来的状态--with-http_realip_module                 //允许从请求标头更改客户端的IP地址值，默认为关--with-http_auth_request_module           //实现基于一个子请求的结果的客户端授权。如果该子请求返回的2xx响应代码，所述接入是允许的。如果它返回401或403中，访问被拒绝与相应的错误代码。由子请求返回的任何其他响应代码被认为是一个错误。--with-http_addition_module               //作为一个输出过滤器，支持不完全缓冲，分部分响应请求--with-http_dav_module                    //增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法 默认关闭，需编译开启--with-http_geoip_module                  //使用预编译的MaxMind数据库解析客户端IP地址，得到变量值--with-http_gunzip_module                 //它为不支持“gzip”编码方法的客户端解压具有“Content-Encoding: gzip”头的响应。--with-http_gzip_static_module            //在线实时压缩输出数据流--with-http_image_filter_module           //传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）--with-http_spdy_module                   //SPDY可以缩短网页的加载时间--with-http_sub_module                    //允许用一些其他文本替换nginx响应中的一些文本--with-http_xslt_module                   //过滤转换XML请求--with-mail                               //启用POP3/IMAP4/SMTP代理模块支持--with-mail_ssl_module                    //启用ngx_mail_ssl_module支持启用外部模块支持<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>8、修改配置文件/etc/nginx/nginx.conf</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 全局参数设置 </span>worker_processes  <span class="token number">4</span><span class="token punctuation">;</span>          <span class="token comment">#设置nginx启动进程的数量，一般设置成与逻辑cpu数量相同 </span>error_log  logs/error.log<span class="token punctuation">;</span>    <span class="token comment">#指定错误日志 </span>worker_rlimit_nofile <span class="token number">102400</span><span class="token punctuation">;</span>  <span class="token comment">#设置一个nginx进程能打开的最大文件数 </span>pid        /var/run/nginx.pid<span class="token punctuation">;</span> <span class="token comment">#nginx开启后会在/var/run/下生成nginx.pid:</span>include /usr/share/nginx/modules/*.conf<span class="token punctuation">;</span>   <span class="token comment"># include 目录下的子配置文件继承主配置文件</span>events <span class="token punctuation">&#123;</span>     worker_connections  <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment">#设置一个进程的最大并发连接数 </span><span class="token punctuation">&#125;</span><span class="token comment"># http 服务相关设置 </span>http <span class="token punctuation">&#123;</span>     include      mime.types<span class="token punctuation">;</span>     default_type  application/octet-stream<span class="token punctuation">;</span>     log_format  main  <span class="token string">'remote_addr - remote_user [time_local] "request" '</span>                      <span class="token string">'status body_bytes_sent "$http_referer" '</span>                      <span class="token string">'"http_user_agent" "http_x_forwarded_for"'</span><span class="token punctuation">;</span>     access_log  /var/log/nginx/access.log  main<span class="token punctuation">;</span>    <span class="token comment">#设置访问日志的位置和格式 </span>    sendfile          on<span class="token punctuation">;</span> <span class="token comment">#是否调用sendfile函数输出文件，一般设置为on，若nginx是用来进行磁盘IO负载应用时，可以设置为off，降低系统负载 </span>    <span class="token function">gzip</span>              on<span class="token punctuation">;</span>      <span class="token comment">#是否开启gzip压缩，将注释去掉开启 </span>    keepalive_timeout  <span class="token number">65</span><span class="token punctuation">;</span>     <span class="token comment">#设置长连接的超时时间</span><span class="token comment"># 虚拟服务器的相关设置 </span>include /etc/nginx/conf.d/*.conf<span class="token punctuation">;</span>   <span class="token comment"># include 在/etc/nginx/conf.d/下，任意以.conf结尾的配置文件均等效在该模块内可生                                                   效，如下方的 server&#123;&#125;   以及server下的location&#123;&#125;</span>        server <span class="token punctuation">&#123;</span>         listen      <span class="token number">80</span><span class="token punctuation">;</span>        <span class="token comment">#设置监听的端口 </span>        server_name  localhost<span class="token punctuation">;</span>        <span class="token comment">#设置绑定的主机名、域名或ip地址 </span>        charset koi8-r<span class="token punctuation">;</span>        <span class="token comment"># 设置编码字符 </span>        location / <span class="token punctuation">&#123;</span>             root  /var/www/nginx<span class="token punctuation">;</span>           <span class="token comment">#设置服务器默认网站的根目录位置,需要手动创建</span>            index  index.html index.htm<span class="token punctuation">;</span>    <span class="token comment">#设置默认打开的文档 </span>            <span class="token punctuation">&#125;</span>         error_page  <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html<span class="token punctuation">;</span> <span class="token comment">#设置错误信息返回页面 </span>        location <span class="token operator">=</span> /50x.html <span class="token punctuation">&#123;</span>             root  html<span class="token punctuation">;</span>        <span class="token comment">#这里的绝对位置是/usr/local/nginx/html</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx.conf的组成:nginx.conf一共由三部分组成，分别为：全局块、events块、http块。在http块中又包含http全局块、多个server块。每个server块中又包含server全局块以及多个location块。在统一配置块中嵌套的配置快，各个之间不存在次序关系。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>检测nginx配置文件是否正确</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># /usr/local/nginx/sbin/nginx -t</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /tmp/nginx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>10、启动nginx服务</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># /usr/local/nginx/sbin/nginx</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>11、通过 nginx 命令控制 nginx 服务</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx -c /path/nginx.conf       <span class="token comment"># 以特定目录下的配置文件启动nginx:</span>nginx -s reload              <span class="token comment"># 修改配置后重新加载生效</span>nginx -s reopen     <span class="token comment"># 重新打开日志文件</span>nginx -s stop    <span class="token comment"># 快速停止nginx</span>nginx -s quit     <span class="token comment"># 完整有序的停止nginx</span>nginx -t     <span class="token comment"># 测试当前配置文件是否正确</span>nginx -t -c /path/to/nginx.conf  <span class="token comment"># 测试特定的nginx配置文件是否正确</span>注意：nginx -s reload 命令加载修改后的配置文件,命令下达后发生如下事件<span class="token number">1</span>. Nginx的master进程检查配置文件的正确性，若是错误则返回错误信息，nginx继续采用原配置文件进行工作（因为worker未受到影响）<span class="token number">2</span>. Nginx启动新的worker进程，采用新的配置文件<span class="token number">3</span>. Nginx将新的请求分配新的worker进程<span class="token number">4</span>. Nginx等待以前的worker进程的全部请求已经都返回后，关闭相关worker进程<span class="token number">5</span>. 重复上面过程，知道全部旧的worker进程都被关闭掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>12、实现nginx开机自启</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># vim /etc/init.d/nginx</span><span class="token comment">#!/bin/sh </span><span class="token comment"># </span><span class="token comment"># nginx - this script starts and stops the nginx daemon </span><span class="token comment"># </span><span class="token comment"># chkconfig:  - 85 15  </span><span class="token comment"># description:  Nginx is an HTTP(S) server, HTTP(S) reverse \ </span><span class="token comment">#              proxy and IMAP/POP3 proxy server </span><span class="token comment"># processname: nginx </span><span class="token comment"># config:      /etc/nginx/nginx.conf </span><span class="token comment"># config:      /etc/sysconfig/nginx </span><span class="token comment"># pidfile:    /var/run/nginx.pid </span>  <span class="token comment"># Source function library. </span><span class="token builtin class-name">.</span> /etc/rc.d/init.d/functions  <span class="token comment"># Source networking configuration. </span><span class="token builtin class-name">.</span> /etc/sysconfig/network  <span class="token comment"># Check that networking is up. </span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$NETWORKING</span>"</span> <span class="token operator">=</span> <span class="token string">"no"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>   <span class="token assign-left variable">nginx</span><span class="token operator">=</span><span class="token string">"/usr/local/nginx/sbin/nginx"</span><span class="token assign-left variable">prog</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $nginx<span class="token variable">)</span></span>   <span class="token assign-left variable">NGINX_CONF_FILE</span><span class="token operator">=</span><span class="token string">"/etc/nginx/nginx.conf"</span>  <span class="token punctuation">[</span> -f /etc/sysconfig/nginx <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">.</span> /etc/sysconfig/nginx  <span class="token assign-left variable">lockfile</span><span class="token operator">=</span>/var/lock/nginx  <span class="token function-name function">make_dirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment"># make required directories </span>  <span class="token assign-left variable">user</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>nginx -V <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"configure arguments:"</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/[^*]*--user=\([^ ]*\).*/\1/g'</span> -<span class="token variable">`</span></span>   <span class="token assign-left variable">options</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>$nginx -V <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'configure arguments:'</span><span class="token variable">`</span></span>   <span class="token keyword">for</span> <span class="token for-or-select variable">opt</span> <span class="token keyword">in</span> <span class="token variable">$options</span><span class="token punctuation">;</span> <span class="token keyword">do</span>      <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> $opt <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'.*-temp-path'</span><span class="token variable">`</span></span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>          <span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> $opt <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">"="</span> -f <span class="token number">2</span><span class="token variable">`</span></span>           <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -d <span class="token string">"<span class="token variable">$value</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>              <span class="token comment"># echo "creating" $value </span>              <span class="token function">mkdir</span> -p <span class="token variable">$value</span> <span class="token operator">&amp;&amp;</span> <span class="token function">chown</span> -R <span class="token variable">$user</span> <span class="token variable">$value</span>           <span class="token keyword">fi</span>      <span class="token keyword">fi</span>  <span class="token keyword">done</span><span class="token punctuation">&#125;</span>   <span class="token function-name function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token punctuation">[</span> -x <span class="token variable">$nginx</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">5</span>     <span class="token punctuation">[</span> -f <span class="token variable">$NGINX_CONF_FILE</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">6</span>     make_dirs     <span class="token builtin class-name">echo</span> -n $<span class="token string">"Starting <span class="token variable">$prog</span>: "</span>    daemon <span class="token variable">$nginx</span> -c <span class="token variable">$NGINX_CONF_FILE</span>     <span class="token assign-left variable">retval</span><span class="token operator">=</span><span class="token variable">$?</span>     <span class="token builtin class-name">echo</span>    <span class="token punctuation">[</span> <span class="token variable">$retval</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">touch</span> <span class="token variable">$lockfile</span>     <span class="token builtin class-name">return</span> <span class="token variable">$retval</span> <span class="token punctuation">&#125;</span>   <span class="token function-name function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token builtin class-name">echo</span> -n $<span class="token string">"Stopping <span class="token variable">$prog</span>: "</span>    killproc <span class="token variable">$prog</span> -QUIT     <span class="token assign-left variable">retval</span><span class="token operator">=</span><span class="token variable">$?</span>     <span class="token builtin class-name">echo</span>    <span class="token punctuation">[</span> <span class="token variable">$retval</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -f <span class="token variable">$lockfile</span>     <span class="token builtin class-name">return</span> <span class="token variable">$retval</span> <span class="token punctuation">&#125;</span>   <span class="token function-name function">restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     configtest <span class="token operator">||</span> <span class="token builtin class-name">return</span> <span class="token variable">$?</span>     stop     <span class="token function">sleep</span> <span class="token number">1</span>     start <span class="token punctuation">&#125;</span>   <span class="token function-name function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     configtest <span class="token operator">||</span> <span class="token builtin class-name">return</span> <span class="token variable">$?</span>     <span class="token builtin class-name">echo</span> -n $<span class="token string">"Reloading <span class="token variable">$prog</span>: "</span>    killproc <span class="token variable">$nginx</span> -HUP     <span class="token assign-left variable">RETVAL</span><span class="token operator">=</span><span class="token variable">$?</span>     <span class="token builtin class-name">echo</span><span class="token punctuation">&#125;</span>   <span class="token function-name function">force_reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     restart <span class="token punctuation">&#125;</span>   <span class="token function-name function">configtest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token variable">$nginx</span> -t -c <span class="token variable">$NGINX_CONF_FILE</span> <span class="token punctuation">&#125;</span>   <span class="token function-name function">rh_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     status <span class="token variable">$prog</span> <span class="token punctuation">&#125;</span>   <span class="token function-name function">rh_status_q</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     rh_status <span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token punctuation">&#125;</span>   <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token keyword">in</span>    start<span class="token punctuation">)</span>         rh_status_q <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>         <span class="token variable">$1</span>         <span class="token punctuation">;</span><span class="token punctuation">;</span>     stop<span class="token punctuation">)</span>         rh_status_q <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>         <span class="token variable">$1</span>         <span class="token punctuation">;</span><span class="token punctuation">;</span>     restart<span class="token operator">|</span>configtest<span class="token punctuation">)</span>         <span class="token variable">$1</span>         <span class="token punctuation">;</span><span class="token punctuation">;</span>     reload<span class="token punctuation">)</span>         rh_status_q <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">7</span>         <span class="token variable">$1</span>         <span class="token punctuation">;</span><span class="token punctuation">;</span>     force-reload<span class="token punctuation">)</span>         force_reload         <span class="token punctuation">;</span><span class="token punctuation">;</span>     status<span class="token punctuation">)</span>         rh_status         <span class="token punctuation">;</span><span class="token punctuation">;</span>     condrestart<span class="token operator">|</span>try-restart<span class="token punctuation">)</span>         rh_status_q <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>             <span class="token punctuation">;</span><span class="token punctuation">;</span>     *<span class="token punctuation">)</span>         <span class="token builtin class-name">echo</span> $<span class="token string">"Usage: <span class="token variable">$0</span> &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;"</span>        <span class="token builtin class-name">exit</span> <span class="token number">2</span> <span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b、添加权限</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">chmod</span> +x /etc/init.d/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>c、重新加载系统启动文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>d、启动并设置开机自启</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl start nginx<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># /sbin/chkconfig nginx on ---开机启动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 编译安装 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
