<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nginx反向代理与负载均衡</title>
      <link href="/2021/08/14/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2021/08/14/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1、nginx-Proxy-代理"><a href="#1、nginx-Proxy-代理" class="headerlink" title="1、nginx Proxy 代理"></a>1、nginx Proxy 代理</h3><p><strong>1、nginx Proxy 配置</strong></p><p>1、代理模块</p><pre class=" language-shell"><code class="language-shell">ngx_http_proxy_module</code></pre><p>2、代理配置</p><pre class=" language-shell"><code class="language-shell">代理Syntax:     proxy_pass URL;                   #代理的后端服务器URLDefault:     —Context:     location, if in location, limit_except缓冲区Syntax:     proxy_buffering on | off;Default:    proxy_buffering on;               #缓冲开关Context:     http, server, locationproxy_buffering开启的情况下，nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端（边收边传，不是全部接收完再传给客户端)。Nginx 全局配置中的 tcp_nopush 的作用就是 数据包会累计到一定大小之后才会发送 。而 tcp_nodelay 是尽快发送数据，所以若你启用了 buffer，建议关闭 tcp_nodelay。Syntax:       proxy_buffer_size size;Default:     proxy_buffer_size 4k|8k;       #缓冲区大小Context:     http, server, locationSyntax:     proxy_buffers number size;Default:     proxy_buffers 8 4k|8k;           #缓冲区数量Context:     http, server, locationSyntax:        proxy_busy_buffers_size size;Default:     proxy_busy_buffers_size 8k|16k;#忙碌的缓冲区大小控制同时传递给客户端的buffer数量Context:     http, server, location头信息Syntax:     proxy_set_header field value;Default:     proxy_set_header Host $proxy_host;        #设置真实客户端地址            proxy_set_header Connection close;Context:     http, server, location超时Syntax:     proxy_connect_timeout time;Default:     proxy_connect_timeout 60s;                #链接超时Context:     http, server, locationSyntax:     proxy_read_timeout time;Default:     proxy_read_timeout 60s;Context:     http, server, locationSyntax:     proxy_send_timeout time; #nginx进程向fastcgi进程发送request的整个过程的超时时间Default:     proxy_send_timeout 60s;Context:     http, server, location#buffer 工作原理1. 所有的proxy buffer参数是作用到每一个请求的。每一个请求会安按照参数的配置获得自己的buffer。proxy buffer不是global而是 request的。2. proxy_buffering 是为了开启response buffering of the proxied server，开启后proxy_buffers和proxy_busy_buffers_size参数才会起作用。3. 无论proxy_buffering是否开启，proxy_buffer_size（main buffer）都是工作的，proxy_buffer_size所设置的buffer_size的作用是用来存储upstream端response的header。4. 在proxy_buffering 开启的情况下，Nginx将会尽可能的读取所有的upstream端传输的数据到buffer，直到proxy_buffers设置的所有buffer们 被写满或者数据被读取完(EOF)。此时nginx开始向客户端传输数据，会同时传输这一整串buffer们。同时如果response的内容很大的话，Nginx会接收并把他们写入到temp_file里去。大小由proxy_max_temp_file_size控制。如果busy的buffer 传输完了会从temp_file里面接着读数据，直到传输完毕。5. 一旦proxy_buffers设置的buffer被写入，直到buffer里面的数据被完整的传输完（传输到客户端），这个buffer将会一直处 在busy状态，我们不能对这个buffer进行任何别的操作。所有处在busy状态的buffer size加起来不能超过proxy_busy_buffers_size，所以proxy_busy_buffers_size是用来控制同时传输到客户端的buffer数量的。</code></pre><p><strong>2、启用 nginx proxy 代理</strong></p><p>环境两台nginx真实服务器</p><p>a、nginx-1 启动网站(内容)（作为网站服务器）</p><p>b、nginx-2 启动代理程序</p><pre class=" language-shell"><code class="language-shell">nginx-2的ip:10.0.105.202配置nginx的yum源直接yum安装启动编辑nginx的配置文件:[root@nginx-server ~]# vim /etc/nginx/conf.d/*.confserver &#123;    server &#123;    listen       80;    server_name  localhost;    location / &#123;    proxy_pass http://10.0.105.199:80;    proxy_redirect default;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    #proxy_set_header REMOTE-HOST $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_connect_timeout 30;    proxy_send_timeout 60;    proxy_read_timeout 60;    proxy_buffering on;    proxy_buffer_size 32k;    proxy_buffers 4 128k;    proxy_busy_buffers_size 256k;    proxy_max_temp_file_size 256k;    &#125;&#125;重新加载nginx配置文件[root@nginx-server ~]# nginx -s reload</code></pre><p>c、nginx proxy 具体配置详解</p><pre class=" language-shell"><code class="language-shell">proxy_pass ：真实服务器的地址，可以是ip也可以是域名和url地址proxy_redirect ：如果真实服务器使用的是的真实IP:非默认端口。则改成IP：默认端口。proxy_set_header：重新定义或者添加发往后端服务器的请求头proxy_set_header X-Real-IP ：启用客户端真实地址（否则日志中显示的是代理在访问网站）proxy_set_header X-Forwarded-For：记录代理地址proxy_connect_timeout：:后端服务器连接的超时时间发起三次握手等候响应超时时间proxy_send_timeout：后端服务器数据回传时间就是在规定时间之内后端服务器必须传完所有的数据proxy_read_timeout ：nginx接收upstream（上游/真实） server数据超时, 默认60s, 如果连续的60s内没有收到1个字节, 连接关闭。像长连接proxy_buffering on;开启缓存proxy_buffer_size：proxy_buffer_size只是响应头的缓冲区proxy_buffers 4 128k; 内容缓冲区域大小proxy_busy_buffers_size 256k; 从proxy_buffers划出一部分缓冲区来专门向客户端传送数据的地方proxy_max_temp_file_size 256k;超大的响应头存储成文件。</code></pre><pre class=" language-shell"><code class="language-shell">proxy_set_header X-Real-IP 未配置Nginxbackend 的日志：记录只有192.168.107.112配置Nginxbackend 的日志,记录的有192.168.107.16 192.168.107.107 192.168.107.112proxy_buffers 的缓冲区大小一般会设置的比较大，以应付大网页。 proxy_buffers当中单个缓冲区的大小是由系统的内存页面大小决定的，Linux系统中一般为4k。 proxy_buffers由缓冲区数量和缓冲区大小组成的。总的大小为number*size。若某些请求的响应过大,则超过_buffers的部分将被缓冲到硬盘(缓冲目录由_temp_path指令指定), 当然这将会使读取响应的速度减慢, 影响用户体验. 可以使用proxy_max_temp_file_size指令关闭磁盘缓冲.</code></pre><p>更多详细代理设置参考官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header</a></p><p>观察nginx-1服务器的日志 (记得打开下面的日志路径,默认为/var/log)</p><pre class=" language-shell"><code class="language-shell">10.0.105.202 - - [27/Jun/2019:15:54:17 +0800] "GET / HTTP/1.0" 304 0 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36" "10.0.105.207"</code></pre><p>10.0.105.202  代理服务器地址</p><p>10.0.105.207 客户机地址。</p><p>访问成功。 记录了客户机的IP和代理服务器的IP</p><h3 id="2、Nginx负载均衡"><a href="#2、Nginx负载均衡" class="headerlink" title="2、Nginx负载均衡"></a>2、Nginx负载均衡</h3><p><a href="https://zhuanlan.zhihu.com/p/64777456">https://zhuanlan.zhihu.com/p/64777456</a>  知乎对7层负载的介绍</p><h6 id="1、负载均衡的作用"><a href="#1、负载均衡的作用" class="headerlink" title="1、负载均衡的作用"></a>1、负载均衡的作用</h6><p>如果你的nginx服务器给2台web服务器做代理，负载均衡算法采用轮询，那么当你的一台机器web程序关闭造成web不能访问，那么nginx服务器分发请求还是会给这台不能访问的web服务器，如果这里的响应连接时间过长，就会导致客户端的页面一直在等待响应，对用户来说体验就打打折扣，这里我们怎么避免这样的情况发生呢。</p><p>如果负载均衡中其中web2发生这样的情况，nginx首先会去web1请求，但是nginx在配置不当的情况下会继续分发请求道web2，然后等待web2响应，直到我们的响应时间超时，才会把请求重新分发给web1，这里的响应时间如果过长，用户等待的时间就会越长。</p><p>下面的配置是解决方案之一。</p><pre class=" language-shell"><code class="language-shell">proxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否中断对被代理服务器的请求。默认为off。</code></pre><p>使用upstream指令配置一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一组服务器处理.</p><pre class=" language-shell"><code class="language-shell">proxy_next_upstream timeout;  #反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off</code></pre><p>error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误。</p><p>timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时。</p><p>invalid_header:被代理服务器返回的响应头异常。</p><p>off:无法将请求分发给被代理的服务器。</p><p>http_400，….:被代理服务器返回的状态码为400，500，502，等</p><p>2、upstream配置</p><p>首先给大家说下 upstream 这个配置的，这个配置是写一组被代理的服务器地址，然后配置负载均衡的算法。这里的被代理服务器地址有2中写法。</p><pre class=" language-shell"><code class="language-shell">upstream testapp &#123;       server 10.0.105.199:8081;      server 10.0.105.202:8081;    &#125; server &#123;        ....        location / &#123;                    proxy_pass  http://testapp;  #请求转向 testapp 定义的服务器列表                 &#125; </code></pre><pre class=" language-shell"><code class="language-shell">upstream mysvr &#123;       server  http://10.0.105.199:8081;      server  http://10.0.105.202:8081;    &#125; server &#123;        ....        location  / &#123;                    proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表                 &#125; </code></pre><h6 id="1、负载均衡算法"><a href="#1、负载均衡算法" class="headerlink" title="1、负载均衡算法"></a>1、负载均衡算法</h6><p>upstream 支持4种负载均衡调度算法:</p><p>A、<code>轮询(默认)</code>:每个请求按时间顺序逐一分配到不同的后端服务器;</p><p>B、<code>ip_hash</code>:每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</p><p>C、<code>url_hash</code>:按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器。后台服务器为缓存的时候提高效率。</p><p>D、<code>fair</code>:这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。<code>Nginx</code>本身是不支持 <code>fair</code>的，如果需要使用这种调度算法，必须下载Nginx的 <code>upstream_fair</code>模块。</p><p><strong>2、配置实例</strong></p><p>1、热备：如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB…..</p><pre class=" language-shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;       server 172.17.14.3:8080 backup;  #热备         &#125;</code></pre><p>2、轮询：nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB….</p><pre class=" language-shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;      server 172.17.14.3:8080;    &#125;</code></pre><p>3、加权轮询：跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB….</p><pre class=" language-shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080 weight=1;      server 172.17.14.3:8080 weight=2;&#125;</code></pre><p>4、ip_hash:nginx会让相同的客户端ip请求相同的服务器。</p><pre class=" language-shell"><code class="language-shell">upstream myweb &#123;       server 172.17.14.2:8080;       server 172.17.14.3:8080;      ip_hash;    &#125;</code></pre><p>5、nginx负载均衡配置状态参数</p><ul><li>down，表示当前的server暂时不参与负载均衡。</li><li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li><li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li><li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间单位秒。max_fails可以和fail_timeout一起使用。</li></ul><pre class=" language-shell"><code class="language-shell"> upstream myweb &#123;       server 172.17.14.2:8080 weight=2 max_fails=2 fail_timeout=2;      server 172.17.14.3:8080 weight=1 max_fails=2 fail_timeout=1;        &#125;</code></pre><p>如果你像跟多更深入的了解 nginx 的负载均衡算法，nginx官方提供一些插件大家可以了解下。 </p><p>Nginx官方文档：<a href="http://nginx.org/en/docs/http/load_balancing.html">http://nginx.org/en/docs/http/load_balancing.html</a></p><h6 id="3、nginx配置7层协议及4层协议方法（扩展）"><a href="#3、nginx配置7层协议及4层协议方法（扩展）" class="headerlink" title="3、nginx配置7层协议及4层协议方法（扩展）"></a>3、nginx配置7层协议及4层协议方法（扩展）</h6><p>准备三台机器:</p><p>代理服务器配置本地host解析域名；</p><p>后端服务器两台，需安装nginx并将nginx服务启动</p><h6 id="——配置代理服务器的nginx配置文件-相对完整的配置-——"><a href="#——配置代理服务器的nginx配置文件-相对完整的配置-——" class="headerlink" title="——配置代理服务器的nginx配置文件(相对完整的配置)——"></a>——配置代理服务器的nginx配置文件(相对完整的配置)——</h6><pre class=" language-shell"><code class="language-shell">worker_processes  4;worker_rlimit_nofile 102400;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main;    sendfile        on;    keepalive_timeout  65;    gzip  on;    upstream testweb &#123;   代理服务器分组    ip_hash;          server 10.0.105.199:80 weight=2 max_fails=2 fail_timeout=2s;       server 10.0.105.202:80 weight=2 max_fails=2 fail_timeout=2s;        &#125;    server &#123;        listen       80;        server_name  www.test.com;        charset utf-8;        #access_log  logs/host.access.log  main;        location / &#123;        proxy_pass http://testweb;                proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            &#125;        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;            &#125;    &#125;     upstream testapp &#123;     server 10.0.105.202:8081 weight=2 max_fails=2 fail_timeout=2s;      server 10.0.105.199:8081 weight=2 max_fails=2 fail_timeout=2s;                   &#125;     server &#123;    listen        81;    server_name    www.app.com;    charset utf-8;    #access_log  logs/host.access.log  main;    location / &#123;        proxy_pass http://testapp;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        &#125;    &#125;&#125;</code></pre><p>浏览器测试访问:</p><p><a href="http://www.test.com/">http://www.test.com/</a></p><p><a href="http://www.app.com:81/">http://www.app.com:81/</a></p><p>202服务器yum安装的创建新的配置文件:</p><pre class=" language-shell"><code class="language-shell">[root@nginx-server ~]# cd /etc/nginx/conf.d/[root@nginx-server conf.d]# cp default.conf test.conf[root@nginx-server conf.d]# cat test.conf server &#123;    listen       80;    server_name  localhost;    location / &#123;         root   /usr/share/nginx/html;         index  index.html index.htm;    &#125;&#125;server &#123;    listen       8081;    server_name  localhost;    location / &#123;         root   /var/www/nginx/html;         index  index.html index.htm;    &#125;&#125;[root@nginx-server ~]# nginx -s reload</code></pre><p>nginx在1.9.0的时候，增加了一个 stream 模块，用来实现四层协议（网络层和传输层）的转发、代理、负载均衡等。stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。</p><pre class=" language-shell"><code class="language-shell">#4层tcp负载 stream &#123;            upstream myweb &#123;                hash $remote_addr consistent;                server 172.17.14.2:8080;                server 172.17.14.3:8080;        &#125;        server &#123;            listen 82;            proxy_connect_timeout 10s;            proxy_timeout 30s;            proxy_pass myweb;        &#125;&#125;</code></pre><p><strong>nginx 会话保持</strong></p><p>nginx会话保持主要有以下几种实现方式。</p><h5 id="1、ip-hash"><a href="#1、ip-hash" class="headerlink" title="1、ip_hash"></a><strong>1、ip_hash</strong></h5><p>ip_hash使用源地址哈希算法，将同一客户端的请求总是发往同一个后端服务器，除非该服务器不可用。</p><p>ip_hash语法：</p><pre class=" language-shell"><code class="language-shell">upstream backend &#123;    ip_hash;    server backend1.example.com;    server backend2.example.com;    server backend3.example.com down;&#125;</code></pre><p>ip_hash简单易用，但有如下问题：<br>当后端服务器宕机后，session会丢失；<br>来自同一局域网的客户端会被转发到同一个后端服务器，可能导致负载失衡；<br>不适用于CDN网络，不适用于前段还有代理的情况。</p><h5 id="2、sticky-cookie-insert"><a href="#2、sticky-cookie-insert" class="headerlink" title="2、sticky_cookie_insert"></a>2、sticky_cookie_insert</h5><p>使用sticky_cookie_insert启用会话亲缘关系，这会导致来自同一客户端的请求被传递到一组服务器的同一台服务器。与ip_hash不同之处在于，它不是基于IP来判断客户端的，而是基于cookie来判断。因此可以避免上述ip_hash中来自同一局域网的客户端和前段代理导致负载失衡的情况。(需要引入第三方模块才能实现)<br>语法：</p><pre class=" language-shell"><code class="language-shell">upstream backend &#123;    server backend1.example.com;    server backend2.example.com;    sticky_cookie_insert srv_id expires=1h domain=3evip.cn path=/;&#125;</code></pre><p>说明：<br>expires：设置浏览器中保持cookie的时间<br>domain：定义cookie的域<br>path：为cookie定义路径</p><h5 id="3、jvm-route方式"><a href="#3、jvm-route方式" class="headerlink" title="3、jvm_route方式"></a><strong>3、jvm_route方式</strong></h5><p>　　jvm_route是通过session_cookie这种方式来实现session粘性。将特定会话附属到特定tomcat上，从而解决session不同步问题，但是无法解决宕机后会话转移问题。如果在cookie和url中并没有session，则这只是个简单的round-robin负载均衡。</p><p>　　jvm_route的原理</p><ul><li>一开始请求过来，没有带session的信息，jvm_route就根据round robin的方法，发到一台Tomcat上面</li><li>Tomcat添加上session信息，并返回给客户</li><li>用户再次请求，jvm_route看到session中有后端服务器的名称，他就把请求转到对应的服务器上</li></ul><p>　　暂时jvm_route模块还不支持fair的模式。jvm_route的工作模式和fair是冲突的。对于某个特定用户，当一直为他服务的Tomcat宕机后，默认情况下它会重试max_fails的次数，如果还是失败，就重新启用round robin的方式，而这种情况下就会导致用户的session丢失。</p><p><strong>4、使用后端服务器自身通过相关机制保持session同步，如：使用数据库、redis、memcached 等做session复制</strong></p><p>cookie和session的区别和用法参考： <a href="http://www.cnblogs.com/ityouknow/p/10856177.html">www.cnblogs.com/ityouknow/p/10856177.html</a></p><h3 id="nginx-实现动静分离"><a href="#nginx-实现动静分离" class="headerlink" title="nginx 实现动静分离"></a>nginx 实现动静分离</h3><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 在动静分离的tomcat的时候比较明显，因为tomcat解析静态很慢，其实这些原理的话都很好理解，简单来说，就是使用正则表达式匹配过滤，然后交个不同的服务器。</p><p><strong>1、准备环境</strong></p><p>准备一个nginx代理 两个http 分别处理动态和静态。</p><pre class=" language-shell"><code class="language-shell">1.配置nginx反向代理upstream；upstream static &#123;        server 10.0.105.196:80 weight=1 max_fails=1 fail_timeout=60s;        &#125;upstream php &#123;        server 10.0.105.200:80 weight=1 max_fails=1 fail_timeout=60s;        &#125;     server &#123;        listen      80;        server_name     localhost;        #动态资源加载        location ~ \.(php|jsp)$ &#123;            proxy_pass http://php;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                &#125;        #静态资源加载        location ~ .*\.(html|gif|jpg|png|bmp|swf|css|js)$ &#123;            proxy_pass http://static;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                &#125;        &#125;</code></pre><pre class=" language-shell"><code class="language-shell">静态资源配置server &#123;        listen 80;        server_name     localhost;        location ~ \.(html|jpg|png|js|css|gif|bmp|jpeg) &#123;        root /home/www/nginx;        &#125;&#125;</code></pre><pre class=" language-shell"><code class="language-shell">动态资源配置:yum 安装php7.1[root@nginx-server ~]#rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm[root@nginx-server ~]#rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm[root@nginx-server ~]#yum install php71w-xsl php71w php71w-ldap php71w-cli php71w-common php71w-devel php71w-gd php71w-pdo php71w-mysql php71w-mbstring php71w-bcmath php71w-mcrypt -y[root@nginx-server ~]#yum install -y php71w-fpm[root@nginx-server ~]#systemctl start php-fpm[root@nginx-server ~]#systemctl enable php-fpm编辑nginx的配置文件:server &#123;        listen      80;        server_name     localhost;        location ~ \.php$ &#123;            root           /home/nginx/html;  #指定网站目录            fastcgi_pass   127.0.0.1:9000;    #指定访问地址            fastcgi_index  index.php;        #指定默认文件            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name; #站点根目录，取决于root配置项            include        fastcgi_params;  #包含nginx常量定义                &#125;        &#125;</code></pre><p>当访问静态页面的时候location 匹配到 (html|jpg|png|js|css|gif|bmp|jpeg) 通过转发到静态服务器，静态服务通过location的正则匹配来处理请求。</p><p>当访问动态页面时location匹配到 .php 结尾的文件转发到后端php服务处理请求。</p><h3 id><a href="#" class="headerlink" title></a></h3><h6 id="-1"><a href="#-1" class="headerlink" title></a></h6>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 反向代理 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx编译安装</title>
      <link href="/2021/08/13/nginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
      <url>/2021/08/13/nginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="1、nginx-编译安装与配置使用"><a href="#1、nginx-编译安装与配置使用" class="headerlink" title="1、nginx 编译安装与配置使用"></a>1、nginx 编译安装与配置使用</h3><h5 id="1、安装编译环境"><a href="#1、安装编译环境" class="headerlink" title="1、安装编译环境"></a>1、安装编译环境</h5><p><code>yum -y install gcc gcc-c++</code></p><h5 id="2、安装pcre软件包（使nginx支持http-rewrite模块）"><a href="#2、安装pcre软件包（使nginx支持http-rewrite模块）" class="headerlink" title="2、安装pcre软件包（使nginx支持http rewrite模块）"></a>2、安装pcre软件包（使nginx支持http rewrite模块）</h5><p><code>yum install -y pcre pcre-devel</code></p><h5 id="3、安装openssl-devel（使nginx支持ssl）"><a href="#3、安装openssl-devel（使nginx支持ssl）" class="headerlink" title="3、安装openssl-devel（使nginx支持ssl）"></a>3、安装openssl-devel（使nginx支持ssl）</h5><p><code>yum install -y openssl openssl-devel </code></p><h5 id="4、安装zlib"><a href="#4、安装zlib" class="headerlink" title="4、安装zlib"></a>4、安装zlib</h5><p><code>yum install -y zlib zlib-devel</code></p><h5 id="5、创建用户nginx"><a href="#5、创建用户nginx" class="headerlink" title="5、创建用户nginx"></a>5、创建用户nginx</h5><p><code>useradd nginx </code></p><p><code>passwd nginx</code>  （系统用户不给予密码更安全）</p><p><strong>6、安装nginx</strong></p><pre class=" language-shell"><code class="language-shell">[root@localhost ~]# wget http://nginx.org/download/nginx-1.16.0.tar.gz[root@localhost ~]# tar xzf nginx-1.16.0.tar.gz -C /usr/local/[root@localhost ~]# cd nginx-1.16.0[root@localhost ~]# wget https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz      # 此处为下载一个echo-nginx-module模块，可实现在nginx配置文件中使用echo打印，辅助排错，可不装[root@localhost ~]# tar xf v0.61.tar.gz[root@localhost nginx-1.16.0]# ./configure --prefix=/usr/local/nginx --group=nginx --user=nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/tmp/nginx/client_body --http-proxy-temp-path=/tmp/nginx/proxy --http-fastcgi-temp-path=/tmp/nginx/fastcgi --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream[root@localhost nginx-1.16.0]# make && make install</code></pre><p><strong>7、Nginx 编译参数</strong></p><pre class=" language-shell"><code class="language-shell"># 查看 nginx 安装的模块[root@localhost ~]#/usr/local/nginx/sbin/nginx -V# 模块参数具体功能 --with-cc-opt='-g -O2 -fPIE -fstack-protector    //设置额外的参数将被添加到CFLAGS变量。（FreeBSD或者ubuntu使用）--param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2' --with-ld-opt='-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now' --prefix=/usr/local/nginx                        //指向安装目录--conf-path=/etc/nginx/nginx.conf                //指定配置文件--http-log-path=/var/log/nginx/access.log        //指定访问日志--error-log-path=/var/log/nginx/error.log        //指定错误日志--lock-path=/var/lock/nginx.lock                 //指定lock文件--pid-path=/run/nginx.pid                        //指定pid文件--http-client-body-temp-path=/var/lib/nginx/body    //设定http客户端请求临时文件路径--http-fastcgi-temp-path=/var/lib/nginx/fastcgi     //设定http fastcgi临时文件路径--http-proxy-temp-path=/var/lib/nginx/proxy         //设定http代理临时文件路径--http-scgi-temp-path=/var/lib/nginx/scgi           //设定http scgi临时文件路径--http-uwsgi-temp-path=/var/lib/nginx/uwsgi         //设定http uwsgi临时文件路径--with-debug                                        //启用debug日志--with-pcre-jit                                     //编译PCRE包含“just-in-time compilation”--with-ipv6                                         //启用ipv6支持--with-http_ssl_module                              //启用ssl支持--with-http_stub_status_module                      //获取nginx自上次启动以来的状态--with-http_realip_module                 //允许从请求标头更改客户端的IP地址值，默认为关--with-http_auth_request_module           //实现基于一个子请求的结果的客户端授权。如果该子请求返回的2xx响应代码，所述接入是允许的。如果它返回401或403中，访问被拒绝与相应的错误代码。由子请求返回的任何其他响应代码被认为是一个错误。--with-http_addition_module               //作为一个输出过滤器，支持不完全缓冲，分部分响应请求--with-http_dav_module                    //增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法 默认关闭，需编译开启--with-http_geoip_module                  //使用预编译的MaxMind数据库解析客户端IP地址，得到变量值--with-http_gunzip_module                 //它为不支持“gzip”编码方法的客户端解压具有“Content-Encoding: gzip”头的响应。--with-http_gzip_static_module            //在线实时压缩输出数据流--with-http_image_filter_module           //传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）--with-http_spdy_module                   //SPDY可以缩短网页的加载时间--with-http_sub_module                    //允许用一些其他文本替换nginx响应中的一些文本--with-http_xslt_module                   //过滤转换XML请求--with-mail                               //启用POP3/IMAP4/SMTP代理模块支持--with-mail_ssl_module                    //启用ngx_mail_ssl_module支持启用外部模块支持</code></pre><p><strong>8、修改配置文件/etc/nginx/nginx.conf</strong></p><pre class=" language-shell"><code class="language-shell"># 全局参数设置 worker_processes  4;          #设置nginx启动进程的数量，一般设置成与逻辑cpu数量相同 error_log  logs/error.log;    #指定错误日志 worker_rlimit_nofile 102400;  #设置一个nginx进程能打开的最大文件数 pid        /var/run/nginx.pid; #nginx开启后会在/var/run/下生成nginx.pid:include /usr/share/nginx/modules/*.conf;   # include 目录下的子配置文件继承主配置文件events &#123;     worker_connections  1024; #设置一个进程的最大并发连接数 &#125;# http 服务相关设置 http &#123;     include      mime.types;     default_type  application/octet-stream;     log_format  main  'remote_addr - remote_user [time_local] "request" '                      'status body_bytes_sent "$http_referer" '                      '"http_user_agent" "http_x_forwarded_for"';     access_log  /var/log/nginx/access.log  main;    #设置访问日志的位置和格式     sendfile          on; #是否调用sendfile函数输出文件，一般设置为on，若nginx是用来进行磁盘IO负载应用时，可以设置为off，降低系统负载     gzip              on;      #是否开启gzip压缩，将注释去掉开启     keepalive_timeout  65;     #设置长连接的超时时间# 虚拟服务器的相关设置 include /etc/nginx/conf.d/*.conf;   # include 在/etc/nginx/conf.d/下，任意以.conf结尾的配置文件均等效在该模块内可生                                                   效，如下方的 server&#123;&#125;   以及server下的location&#123;&#125;        server &#123;         listen      80;        #设置监听的端口         server_name  localhost;        #设置绑定的主机名、域名或ip地址         charset koi8-r;        # 设置编码字符         location / &#123;             root  /var/www/nginx;           #设置服务器默认网站的根目录位置,需要手动创建            index  index.html index.htm;    #设置默认打开的文档             &#125;         error_page  500 502 503 504  /50x.html; #设置错误信息返回页面         location = /50x.html &#123;             root  html;        #这里的绝对位置是/usr/local/nginx/html        &#125;     &#125;  &#125;</code></pre><pre class=" language-shell"><code class="language-shell">nginx.conf的组成:nginx.conf一共由三部分组成，分别为：全局块、events块、http块。在http块中又包含http全局块、多个server块。每个server块中又包含server全局块以及多个location块。在统一配置块中嵌套的配置快，各个之间不存在次序关系。</code></pre><p><strong>检测nginx配置文件是否正确</strong></p><pre class=" language-shell"><code class="language-shell">[root@localhost ~]# /usr/local/nginx/sbin/nginx -t[root@localhost ~]# mkdir -p /tmp/nginx</code></pre><p><strong>10、启动nginx服务</strong></p><pre class=" language-shell"><code class="language-shell">[root@localhost ~]# /usr/local/nginx/sbin/nginx</code></pre><p><strong>11、通过 nginx 命令控制 nginx 服务</strong></p><pre class=" language-shell"><code class="language-shell">nginx -c /path/nginx.conf           # 以特定目录下的配置文件启动nginx:nginx -s reload                      # 修改配置后重新加载生效nginx -s reopen                     # 重新打开日志文件nginx -s stop                        # 快速停止nginxnginx -s quit                         # 完整有序的停止nginxnginx -t                         # 测试当前配置文件是否正确nginx -t -c /path/to/nginx.conf  # 测试特定的nginx配置文件是否正确注意：nginx -s reload 命令加载修改后的配置文件,命令下达后发生如下事件1. Nginx的master进程检查配置文件的正确性，若是错误则返回错误信息，nginx继续采用原配置文件进行工作（因为worker未受到影响）2. Nginx启动新的worker进程，采用新的配置文件3. Nginx将新的请求分配新的worker进程4. Nginx等待以前的worker进程的全部请求已经都返回后，关闭相关worker进程5. 重复上面过程，知道全部旧的worker进程都被关闭掉</code></pre><p><strong>12、实现nginx开机自启</strong></p><pre class=" language-shell"><code class="language-shell">[root@localhost ~]# vim /etc/init.d/nginx#!/bin/sh # # nginx - this script starts and stops the nginx daemon # # chkconfig:  - 85 15  # description:  Nginx is an HTTP(S) server, HTTP(S) reverse \ #              proxy and IMAP/POP3 proxy server # processname: nginx # config:      /etc/nginx/nginx.conf # config:      /etc/sysconfig/nginx # pidfile:    /var/run/nginx.pid   # Source function library. . /etc/rc.d/init.d/functions  # Source networking configuration. . /etc/sysconfig/network  # Check that networking is up. [ "$NETWORKING" = "no" ] && exit 0   nginx="/usr/local/nginx/sbin/nginx"prog=$(basename $nginx)   NGINX_CONF_FILE="/etc/nginx/nginx.conf"  [ -f /etc/sysconfig/nginx ] && . /etc/sysconfig/nginx  lockfile=/var/lock/nginx  make_dirs() &#123;   # make required directories   user=`nginx -V 2>&1 | grep "configure arguments:" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`   options=`$nginx -V 2>&1 | grep 'configure arguments:'`   for opt in $options; do      if [ `echo $opt | grep '.*-temp-path'` ]; then          value=`echo $opt | cut -d "=" -f 2`           if [ ! -d "$value" ]; then              # echo "creating" $value               mkdir -p $value && chown -R $user $value           fi      fi  done&#125;   start() &#123;     [ -x $nginx ] || exit 5     [ -f $NGINX_CONF_FILE ] || exit 6     make_dirs     echo -n $"Starting $prog: "    daemon $nginx -c $NGINX_CONF_FILE     retval=$?     echo    [ $retval -eq 0 ] && touch $lockfile     return $retval &#125;   stop() &#123;     echo -n $"Stopping $prog: "    killproc $prog -QUIT     retval=$?     echo    [ $retval -eq 0 ] && rm -f $lockfile     return $retval &#125;   restart() &#123;     configtest || return $?     stop     sleep 1     start &#125;   reload() &#123;     configtest || return $?     echo -n $"Reloading $prog: "    killproc $nginx -HUP     RETVAL=$?     echo&#125;   force_reload() &#123;     restart &#125;   configtest() &#123;   $nginx -t -c $NGINX_CONF_FILE &#125;   rh_status() &#123;     status $prog &#125;   rh_status_q() &#123;     rh_status >/dev/null 2>&1 &#125;   case "$1" in    start)         rh_status_q && exit 0         $1         ;;     stop)         rh_status_q || exit 0         $1         ;;     restart|configtest)         $1         ;;     reload)         rh_status_q || exit 7         $1         ;;     force-reload)         force_reload         ;;     status)         rh_status         ;;     condrestart|try-restart)         rh_status_q || exit 0             ;;     *)         echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;"        exit 2 esac</code></pre><p>b、添加权限</p><pre class=" language-shell"><code class="language-shell">chmod +x /etc/init.d/nginx</code></pre><p>c、重新加载系统启动文件</p><pre class=" language-shell"><code class="language-shell">systemctl daemon-reload</code></pre><p>d、启动并设置开机自启</p><pre class=" language-shell"><code class="language-shell">systemctl start nginx[root@localhost ~]# /sbin/chkconfig nginx on ---开机启动</code></pre>]]></content>
      
      
      <categories>
          
          <category> LNMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 编译安装 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
